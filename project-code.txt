// Relative Path: App.tsx

import '../ReactotronConfig';
import 'react-native-gesture-handler';
import React, { useEffect } from 'react';
import { Platform, StatusBar, StyleSheet } from 'react-native';
import { AppNavigator } from './navigation/AppNavigator';
import { SafeAreaView } from 'react-native-safe-area-context';
import { isFirebaseInitialized } from './config/firebase';

import reactotron from '../ReactotronConfig';


export default function App() {
  useEffect(() => {
    if (Platform.OS === 'android' && __DEV__) {
      // Enviar un log de prueba para verificar la conexión
      reactotron.log('App montada - Verificando conexión de Reactotron');
      
      // Programar logs periódicos para mantener la conexión activa
      const interval = setInterval(() => {
        reactotron.log('Heartbeat de conexión');
      }, 10000);
      
      return () => clearInterval(interval);
    }

    if (!isFirebaseInitialized()) {
      console.error(
        'Firebase initialization failed. Authentication will not work.',
      );
    }
  }, []);

  return (
    <SafeAreaView edges={['top']} style={styles.container}>
      <StatusBar backgroundColor="#c62828" barStyle="light-content" />
      <AppNavigator />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});


// -----------------------------------------------

// Relative Path: config/firebase.ts

import { initializeApp } from '@react-native-firebase/app';
import auth from '@react-native-firebase/auth';

const firebaseConfig = {
  apiKey: 'AIzaSyDOPOoiuUzstU0dB34OtQlZiVjoIGXK1AQ',
  authDomain: 'poc-expo-project.firebaseapp.com',
  projectId: 'poc-expo-project',
  storageBucket: 'poc-expo-project.firebasestorage.app',
  messagingSenderId: '508664549153',
  appId: '1:508664549153:web:b8368d6448884755a67860',
  measurementId: 'G-4853C75V9T',
};

const initializeFirebase = () => {
  if (!firebaseConfig.apiKey) {
    console.warn('Firebase configuration is missing or incomplete');
    return null;
  }

  try {
    const app = initializeApp(firebaseConfig);
    console.log('Firebase initialized successfully');
    return app;
  } catch (error) {
    console.error('Error initializing Firebase:', error);
    return null;
  }
};

export const firebaseApp = initializeFirebase();

export const firebaseAuth = auth();

export const isFirebaseInitialized = () => {
  return !!firebaseApp;
};


// -----------------------------------------------

// Relative Path: features/authentication/components/AuthForm.tsx

import React, { useState, useCallback, useEffect, useRef } from 'react';
import {
  View,
  TextInput,
  StyleSheet,
  Text,
  TouchableOpacity,
  ActivityIndicator,
} from 'react-native';
import { AuthFormState } from '../types/auth.types';
import { useAuthStore } from '../store/authStore';

interface AuthFormProps {
  type: 'login' | 'register' | 'reset';
  onSuccess?: () => void;
  initialValues?: Partial<AuthFormState>;
}

export const AuthForm: React.FC<AuthFormProps> = ({
  type,
  onSuccess,
  initialValues = {},
}) => {
  // Obtener funciones del store directamente para evitar re-renderizados
  const authStore = useRef(useAuthStore.getState());

  // Estados locales
  const [formState, setFormState] = useState<AuthFormState>({
    email: initialValues.email || '',
    password: initialValues.password || '',
    ...(type === 'register'
      ? {
          displayName: initialValues.displayName || '',
          confirmPassword: initialValues.confirmPassword || '',
        }
      : {}),
  });

  const [errors, setErrors] = useState<Record<string, string>>({});
  const [storeError, setStoreError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  // Suscribirse a cambios en el estado de loading y error
  useEffect(() => {
    // Obtener estado inicial
    setIsLoading(authStore.current.isLoading);
    setStoreError(authStore.current.error);

    // Suscribirse a cambios
    const unsubscribe = useAuthStore.subscribe((state) => {
      setIsLoading(state.isLoading);
      setStoreError(state.error);
    });

    return unsubscribe;
  }, []);

  // Manejar cambios en los campos
  const handleChange = useCallback(
    (field: keyof AuthFormState, value: string) => {
      setFormState((prev) => ({ ...prev, [field]: value }));
      // Limpiar error cuando el usuario escribe
      setErrors((prev) => ({ ...prev, [field]: '' }));
      // Limpiar error del store
      authStore.current.clearError();
    },
    [],
  );

  // Validar el formulario
  const validate = useCallback(() => {
    const newErrors: Record<string, string> = {};

    // Validar email
    if (!formState.email) {
      newErrors.email = 'El correo electrónico es requerido';
    } else if (!/\S+@\S+\.\S+/.test(formState.email)) {
      newErrors.email = 'El correo electrónico no es válido';
    }

    // Validar contraseña (solo si se requiere)
    if (type !== 'reset') {
      if (!formState.password) {
        newErrors.password = 'La contraseña es requerida';
      } else if (formState.password.length < 6) {
        newErrors.password = 'La contraseña debe tener al menos 6 caracteres';
      }
    }

    // Validar confirmación de contraseña (solo para registro)
    if (
      type === 'register' &&
      formState.confirmPassword !== formState.password
    ) {
      newErrors.confirmPassword = 'Las contraseñas no coinciden';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [formState, type]);

  // Manejar envío del formulario
  const handleSubmit = useCallback(async () => {
    if (isSubmitting || isLoading) return;

    if (!validate()) return;

    setIsSubmitting(true);
    let success = false;

    try {
      if (type === 'login') {
        await authStore.current.login({
          email: formState.email,
          password: formState.password,
        });
        success = !authStore.current.error;
      } else if (type === 'register') {
        await authStore.current.register({
          email: formState.email,
          password: formState.password,
          displayName: formState.displayName,
        });
        success = !authStore.current.error;
      } else if (type === 'reset') {
        await authStore.current.resetPassword(formState.email);
        success = !authStore.current.error;
      }

      if (success && onSuccess) {
        onSuccess();
      }
    } catch (error) {
      console.error('Error en el envío del formulario:', error);
    } finally {
      setIsSubmitting(false);
    }
  }, [formState, type, isSubmitting, isLoading, validate, onSuccess]);

  return (
    <View style={styles.container}>
      {/* Título del formulario */}
      <Text style={styles.title}>
        {type === 'login'
          ? 'Iniciar Sesión'
          : type === 'register'
            ? 'Crear Cuenta'
            : 'Restablecer Contraseña'}
      </Text>

      {/* Error general del store */}
      {storeError && <Text style={styles.errorText}>{storeError}</Text>}

      {/* Campo de nombre (solo para registro) */}
      {type === 'register' && (
        <View style={styles.inputContainer}>
          <Text style={styles.label}>Nombre</Text>
          <TextInput
            style={styles.input}
            placeholder="Tu nombre"
            value={formState.displayName}
            onChangeText={(value) => handleChange('displayName', value)}
            autoCapitalize="words"
            editable={!isLoading && !isSubmitting}
          />
          {errors.displayName && (
            <Text style={styles.errorText}>{errors.displayName}</Text>
          )}
        </View>
      )}

      {/* Campo de email */}
      <View style={styles.inputContainer}>
        <Text style={styles.label}>Correo Electrónico</Text>
        <TextInput
          style={styles.input}
          placeholder="correo@ejemplo.com"
          value={formState.email}
          onChangeText={(value) => handleChange('email', value)}
          keyboardType="email-address"
          autoCapitalize="none"
          editable={!isLoading && !isSubmitting}
        />
        {errors.email && <Text style={styles.errorText}>{errors.email}</Text>}
      </View>

      {/* Campo de contraseña (no para reset) */}
      {type !== 'reset' && (
        <View style={styles.inputContainer}>
          <Text style={styles.label}>Contraseña</Text>
          <TextInput
            style={styles.input}
            placeholder="Contraseña"
            value={formState.password}
            onChangeText={(value) => handleChange('password', value)}
            secureTextEntry
            editable={!isLoading && !isSubmitting}
          />
          {errors.password && (
            <Text style={styles.errorText}>{errors.password}</Text>
          )}
        </View>
      )}

      {/* Confirmar contraseña (solo para registro) */}
      {type === 'register' && (
        <View style={styles.inputContainer}>
          <Text style={styles.label}>Confirmar Contraseña</Text>
          <TextInput
            style={styles.input}
            placeholder="Confirma tu contraseña"
            value={formState.confirmPassword}
            onChangeText={(value) => handleChange('confirmPassword', value)}
            secureTextEntry
            editable={!isLoading && !isSubmitting}
          />
          {errors.confirmPassword && (
            <Text style={styles.errorText}>{errors.confirmPassword}</Text>
          )}
        </View>
      )}

      {/* Botón de envío */}
      <TouchableOpacity
        style={[
          styles.button,
          (isLoading || isSubmitting) && styles.buttonDisabled,
        ]}
        onPress={handleSubmit}
        disabled={isLoading || isSubmitting}
      >
        {isLoading || isSubmitting ? (
          <ActivityIndicator color="#fff" />
        ) : (
          <Text style={styles.buttonText}>
            {type === 'login'
              ? 'Iniciar Sesión'
              : type === 'register'
                ? 'Registrarse'
                : 'Enviar Correo'}
          </Text>
        )}
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
  inputContainer: {
    marginBottom: 16,
  },
  label: {
    fontSize: 16,
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
  },
  button: {
    backgroundColor: '#c62828',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 16,
  },
  buttonDisabled: {
    backgroundColor: '#cccccc',
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  errorText: {
    color: 'red',
    fontSize: 14,
    marginTop: 4,
  },
});


// -----------------------------------------------

// Relative Path: features/authentication/components/GoogleSignInButton.tsx

import React, { useState, useCallback } from 'react';
import {
  TouchableOpacity,
  Text,
  StyleSheet,
  ActivityIndicator,
  Image,
  View,
} from 'react-native';
import { useAuthStore } from '../store/authStore';

interface GoogleSignInButtonProps {
  onSuccess?: () => void;
}

export const GoogleSignInButton: React.FC<GoogleSignInButtonProps> = ({
  onSuccess,
}) => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const loginWithProvider = useAuthStore((state) => state.loginWithProvider);

  const handleGoogleSignIn = useCallback(async () => {
    if (isLoading) return;

    setIsLoading(true);
    setError(null);

    try {
      await loginWithProvider('google');
      if (onSuccess) {
        onSuccess();
      }
    } catch (err) {
      const errorMessage =
        err instanceof Error
          ? err.message
          : 'Error al iniciar sesión con Google';
      console.error('Error al iniciar sesión con Google:', errorMessage);
      setError(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }, [loginWithProvider, onSuccess, isLoading]);

  return (
    <View style={styles.container}>
      <TouchableOpacity
        style={styles.button}
        onPress={handleGoogleSignIn}
        disabled={isLoading}
      >
        {isLoading ? (
          <ActivityIndicator color="#444" />
        ) : (
          <>
            <Image
              source={require('../../../../assets/google.png')}
              style={styles.icon}
            />
            <Text style={styles.text}>Continuar con Google</Text>
          </>
        )}
      </TouchableOpacity>
      {error && <Text style={styles.errorText}>{error}</Text>}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    marginVertical: 10,
    paddingHorizontal: 16,
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1,
    elevation: 2,
  },
  icon: {
    width: 24,
    height: 24,
    marginRight: 10,
  },
  text: {
    color: '#333',
    fontSize: 16,
    fontWeight: '500',
  },
  errorText: {
    color: 'red',
    fontSize: 14,
    marginTop: 5,
    textAlign: 'center',
  },
});


// -----------------------------------------------

// Relative Path: features/authentication/hooks/useAuthForm.ts

import { useState, useCallback } from 'react';
import { AuthFormState } from '../types/auth.types';
import { useAuthStore } from '../store/authStore';

export function useAuthForm(initialState: AuthFormState) {
  const [formState, setFormState] = useState<AuthFormState>(initialState);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const { login, register, resetPassword, error, clearError } = useAuthStore();

  // Manejar cambios en los campos
  const handleChange = useCallback(
    (field: keyof AuthFormState, value: string) => {
      setFormState((prev) => ({ ...prev, [field]: value }));
      // Limpiar error cuando el usuario escribe
      if (errors[field]) {
        setErrors((prev) => ({ ...prev, [field]: '' }));
      }
      clearError();
    },
    [errors, clearError],
  );

  // Validar el formulario
  const validate = useCallback(() => {
    const newErrors: Record<string, string> = {};

    // Validar email
    if (!formState.email) {
      newErrors.email = 'El correo electrónico es requerido';
    } else if (!/\S+@\S+\.\S+/.test(formState.email)) {
      newErrors.email = 'El correo electrónico no es válido';
    }

    // Validar contraseña (solo si se requiere)
    if ('password' in formState && formState.password === '') {
      newErrors.password = 'La contraseña es requerida';
    } else if ('password' in formState && formState.password.length < 6) {
      newErrors.password = 'La contraseña debe tener al menos 6 caracteres';
    }

    // Validar confirmación de contraseña (solo para registro)
    if (
      'confirmPassword' in formState &&
      formState.confirmPassword !== formState.password
    ) {
      newErrors.confirmPassword = 'Las contraseñas no coinciden';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [formState]);

  // Manejar inicio de sesión
  const handleLogin = useCallback(async () => {
    if (!validate()) return;

    try {
      await login({
        email: formState.email,
        password: formState.password,
      });
    } catch (err) {
      // El error ya se maneja en el store
      console.error(err);
    }
  }, [formState, login, validate]);

  // Manejar registro
  const handleRegister = useCallback(async () => {
    if (!validate()) return;

    try {
      await register({
        email: formState.email,
        password: formState.password,
        displayName: formState.displayName,
      });
    } catch (err) {
      // El error ya se maneja en el store
      console.error(err);
    }
  }, [formState, register, validate]);

  // Manejar restablecimiento de contraseña
  const handleResetPassword = useCallback(async () => {
    // Validar solo el email
    if (!formState.email) {
      setErrors({ email: 'El correo electrónico es requerido' });
      return;
    }

    if (!/\S+@\S+\.\S+/.test(formState.email)) {
      setErrors({ email: 'El correo electrónico no es válido' });
      return;
    }

    try {
      await resetPassword(formState.email);
      return true; // Indicar éxito para mostrar mensaje
    } catch (err) {
      // El error ya se maneja en el store
      console.error(err);
      return false;
    }
  }, [formState.email, resetPassword]);

  return {
    formState,
    errors,
    storeError: error,
    handleChange,
    handleLogin,
    handleRegister,
    handleResetPassword,
    clearError,
  };
}


// -----------------------------------------------

// Relative Path: features/authentication/index.ts

// screens
export { AuthForm } from './components/AuthForm';
export { LoginScreen } from './screens/LoginScreen';
export { RegisterScreen } from './screens/RegisterScreen';
export { PasswordResetScreen } from './screens/PasswordResetScreen';
export { ProfileScreen } from './screens/ProfileScreen';

// Hooks
export { useAuthForm } from './hooks/useAuthForm';

// Store
export { useAuthStore, useAuthUser, useAuthStatus } from './store/authStore';

// Servicios
export { authService } from './services/authService';

// Tipos
export type {
  User,
  AuthState,
  LoginCredentials,
  RegisterCredentials,
  AuthFormState,
} from './types/auth.types';


// -----------------------------------------------

// Relative Path: features/authentication/screens/LoginScreen.tsx

import React from 'react';
import {
  View,
  StyleSheet,
  Text,
  TouchableOpacity,
  SafeAreaView,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { AuthForm } from '../components/AuthForm';
import { GoogleSignInButton } from '../components/GoogleSignInButton';

export const LoginScreen = () => {
  const navigation = useNavigation();

  const handleRegisterPress = () => {
    navigation.navigate('Register' as never);
  };

  const handleForgotPassword = () => {
    navigation.navigate('PasswordReset' as never);
  };

  const handleLoginSuccess = () => {
    // La navegación a la pantalla principal se manejará en el navegador principal
    // basado en el estado de autenticación
  };

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.content}>
        <Text style={styles.logo}>PokéApp</Text>

        <AuthForm type="login" onSuccess={handleLoginSuccess} />

        <View style={styles.dividerContainer}>
          <View style={styles.divider} />
          <Text style={styles.dividerText}>O</Text>
          <View style={styles.divider} />
        </View>

        <GoogleSignInButton onSuccess={handleLoginSuccess} />

        <View style={styles.links}>
          <TouchableOpacity onPress={handleForgotPassword}>
            <Text style={styles.linkText}>¿Olvidaste tu contraseña?</Text>
          </TouchableOpacity>

          <View style={styles.registerContainer}>
            <Text style={styles.registerText}>¿No tienes cuenta?</Text>
            <TouchableOpacity onPress={handleRegisterPress}>
              <Text style={[styles.linkText, styles.registerLink]}>
                Regístrate
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    padding: 20,
  },
  logo: {
    fontSize: 32,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 40,
    color: '#c62828',
  },
  dividerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 20,
  },
  divider: {
    flex: 1,
    height: 1,
    backgroundColor: '#ddd',
  },
  dividerText: {
    marginHorizontal: 10,
    color: '#666',
  },
  links: {
    marginTop: 20,
    alignItems: 'center',
  },
  linkText: {
    color: '#c62828',
    fontSize: 16,
  },
  registerContainer: {
    flexDirection: 'row',
    marginTop: 20,
    justifyContent: 'center',
  },
  registerText: {
    fontSize: 16,
    marginRight: 5,
  },
  registerLink: {
    fontWeight: 'bold',
  },
});


// -----------------------------------------------

// Relative Path: features/authentication/screens/PasswordResetScreen.tsx

import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  Text,
  TouchableOpacity,
  SafeAreaView,
  Alert,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { AuthForm } from '../components/AuthForm';

export const PasswordResetScreen = () => {
  const navigation = useNavigation();
  const [resetSent, setResetSent] = useState(false);

  const handleBackToLogin = () => {
    navigation.navigate('Login' as never);
  };

  const handleResetSuccess = () => {
    setResetSent(true);
    Alert.alert(
      'Correo enviado',
      'Se ha enviado un correo para restablecer tu contraseña',
      [{ text: 'OK' }],
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.content}>
        <Text style={styles.logo}>PokéApp</Text>

        {resetSent ? (
          <View style={styles.successContainer}>
            <Text style={styles.successTitle}>Correo Enviado</Text>
            <Text style={styles.successText}>
              Hemos enviado instrucciones para restablecer tu contraseña al
              correo proporcionado.
            </Text>
            <TouchableOpacity style={styles.button} onPress={handleBackToLogin}>
              <Text style={styles.buttonText}>Volver al inicio de sesión</Text>
            </TouchableOpacity>
          </View>
        ) : (
          <>
            <Text style={styles.resetText}>
              Introduce tu correo electrónico y te enviaremos instrucciones para
              restablecer tu contraseña.
            </Text>

            <AuthForm type="reset" onSuccess={handleResetSuccess} />

            <TouchableOpacity
              style={styles.backLink}
              onPress={handleBackToLogin}
            >
              <Text style={styles.backText}>Volver al inicio de sesión</Text>
            </TouchableOpacity>
          </>
        )}
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    padding: 20,
  },
  logo: {
    fontSize: 32,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 20,
    color: '#c62828',
  },
  resetText: {
    textAlign: 'center',
    marginBottom: 20,
    fontSize: 16,
  },
  backLink: {
    marginTop: 20,
    alignItems: 'center',
  },
  backText: {
    color: '#c62828',
    fontSize: 16,
  },
  successContainer: {
    alignItems: 'center',
    padding: 20,
  },
  successTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  successText: {
    textAlign: 'center',
    marginBottom: 30,
    fontSize: 16,
    lineHeight: 24,
  },
  button: {
    backgroundColor: '#c62828',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    width: '100%',
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
});


// -----------------------------------------------

// Relative Path: features/authentication/screens/ProfileScreen.tsx

import React, { useState, useCallback, useEffect, useRef } from 'react';
import {
  View,
  StyleSheet,
  Text,
  TouchableOpacity,
  SafeAreaView,
  TextInput,
  Alert,
  ActivityIndicator,
  Image,
} from 'react-native';
import { useAuthStore } from '../store/authStore';

export const ProfileScreen: React.FC = () => {
  // Usar useRef para acceder al store y evitar re-renderizados
  const authStoreRef = useRef(useAuthStore.getState());

  // Estados locales
  const [user, setUser] = useState(authStoreRef.current.user);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [displayName, setDisplayName] = useState(user?.displayName || '');

  // Suscribirse a cambios en el usuario y estado de carga
  useEffect(() => {
    const unsubscribe = useAuthStore.subscribe((state) => {
      setUser(state.user);
      setIsLoading(state.isLoading);
      setError(state.error);
    });

    return unsubscribe;
  }, []);

  // Actualizar displayName cuando cambie el usuario
  useEffect(() => {
    if (!isEditing) {
      setDisplayName(user?.displayName || '');
    }
  }, [user, isEditing]);

  // Manejar cierre de sesión
  const handleLogout = useCallback(async () => {
    try {
      setIsLoading(true);
      await authStoreRef.current.logout();
    } catch (error) {
      Alert.alert('Error', 'No se pudo cerrar sesión. Intenta de nuevo.');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Manejar edición
  const handleEdit = useCallback(() => {
    setIsEditing(true);
  }, []);

  // Manejar cancelación
  const handleCancel = useCallback(() => {
    setIsEditing(false);
    setDisplayName(user?.displayName || '');
    authStoreRef.current.clearError();
    setError(null);
  }, [user]);

  // Manejar guardado
  const handleSave = useCallback(async () => {
    try {
      setIsLoading(true);
      await authStoreRef.current.updateProfile({ displayName });
      setIsEditing(false);
      Alert.alert('Éxito', 'Perfil actualizado correctamente');
    } catch (error) {
      // El error ya se maneja en el store y se actualiza a través de la suscripción
    } finally {
      setIsLoading(false);
    }
  }, [displayName]);

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.content}>
        <Text style={styles.title}>Mi Perfil</Text>

        {/* Avatar */}
        <View style={styles.avatarContainer}>
          {user?.photoURL ? (
            <Image source={{ uri: user.photoURL }} style={styles.avatar} />
          ) : (
            <View style={styles.avatarPlaceholder}>
              <Text style={styles.avatarText}>
                {displayName?.charAt(0)?.toUpperCase() ||
                  user?.email?.charAt(0)?.toUpperCase() ||
                  '?'}
              </Text>
            </View>
          )}
        </View>

        {/* Información del usuario */}
        <View style={styles.infoContainer}>
          {error && <Text style={styles.errorText}>{error}</Text>}

          {/* Nombre */}
          <View style={styles.fieldContainer}>
            <Text style={styles.label}>Nombre</Text>
            {isEditing ? (
              <TextInput
                style={styles.input}
                value={displayName}
                onChangeText={setDisplayName}
                placeholder="Tu nombre"
                editable={!isLoading}
              />
            ) : (
              <Text style={styles.value}>
                {user?.displayName || 'Sin nombre'}
              </Text>
            )}
          </View>

          {/* Email */}
          <View style={styles.fieldContainer}>
            <Text style={styles.label}>Correo Electrónico</Text>
            <Text style={styles.value}>{user?.email}</Text>
          </View>

          {/* Estado de verificación */}
          <View style={styles.fieldContainer}>
            <Text style={styles.label}>Estado</Text>
            <Text
              style={[
                styles.value,
                user?.emailVerified ? styles.verified : styles.unverified,
              ]}
            >
              {user?.emailVerified ? 'Verificado' : 'No verificado'}
            </Text>
          </View>

          {/* Botones de acción */}
          <View style={styles.buttonsContainer}>
            {isEditing ? (
              <>
                <TouchableOpacity
                  style={[styles.button, styles.cancelButton]}
                  onPress={handleCancel}
                  disabled={isLoading}
                >
                  <Text style={styles.cancelButtonText}>Cancelar</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={styles.button}
                  onPress={handleSave}
                  disabled={isLoading}
                >
                  {isLoading ? (
                    <ActivityIndicator color="#fff" />
                  ) : (
                    <Text style={styles.buttonText}>Guardar</Text>
                  )}
                </TouchableOpacity>
              </>
            ) : (
              <>
                <TouchableOpacity
                  style={[styles.button, styles.editButton]}
                  onPress={handleEdit}
                  disabled={isLoading}
                >
                  <Text style={styles.editButtonText}>Editar Perfil</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.button, styles.logoutButton]}
                  onPress={handleLogout}
                  disabled={isLoading}
                >
                  {isLoading ? (
                    <ActivityIndicator color="#fff" />
                  ) : (
                    <Text style={styles.buttonText}>Cerrar Sesión</Text>
                  )}
                </TouchableOpacity>
              </>
            )}
          </View>
        </View>
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  content: {
    flex: 1,
    padding: 20,
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 30,
    textAlign: 'center',
  },
  avatarContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  avatar: {
    width: 100,
    height: 100,
    borderRadius: 50,
  },
  avatarPlaceholder: {
    width: 100,
    height: 100,
    borderRadius: 50,
    backgroundColor: '#c62828',
    justifyContent: 'center',
    alignItems: 'center',
  },
  avatarText: {
    color: 'white',
    fontSize: 40,
    fontWeight: 'bold',
  },
  infoContainer: {
    backgroundColor: 'white',
    borderRadius: 10,
    padding: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  fieldContainer: {
    marginBottom: 20,
  },
  label: {
    fontSize: 14,
    color: '#666',
    marginBottom: 5,
  },
  value: {
    fontSize: 18,
    fontWeight: '500',
  },
  verified: {
    color: 'green',
  },
  unverified: {
    color: 'orange',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
  },
  buttonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 20,
  },
  button: {
    flex: 1,
    backgroundColor: '#c62828',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginHorizontal: 5,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  editButton: {
    backgroundColor: '#2196F3',
  },
  cancelButton: {
    backgroundColor: '#f5f5f5',
    borderWidth: 1,
    borderColor: '#ddd',
  },
  logoutButton: {
    backgroundColor: '#c62828',
  },
  editButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  cancelButtonText: {
    color: '#333',
    fontSize: 16,
    fontWeight: 'bold',
  },
  errorText: {
    color: 'red',
    marginBottom: 15,
    textAlign: 'center',
  },
});


// -----------------------------------------------

// Relative Path: features/authentication/screens/RegisterScreen.tsx

import React from 'react';
import {
  View,
  StyleSheet,
  Text,
  TouchableOpacity,
  SafeAreaView,
  ScrollView,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { AuthForm } from '../components/AuthForm';
import { GoogleSignInButton } from '../components/GoogleSignInButton';

export const RegisterScreen = () => {
  const navigation = useNavigation();

  const handleLoginPress = () => {
    navigation.navigate('Login' as never);
  };

  const handleRegisterSuccess = () => {
    // La navegación a la pantalla principal se manejará en el navegador principal
    // basado en el estado de autenticación
  };

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView contentContainerStyle={styles.content}>
        <Text style={styles.logo}>PokéApp</Text>

        <AuthForm type="register" onSuccess={handleRegisterSuccess} />
        <View style={styles.dividerContainer}>
          <View style={styles.divider} />
          <Text style={styles.dividerText}>O</Text>
          <View style={styles.divider} />
        </View>

        <GoogleSignInButton onSuccess={handleRegisterSuccess} />

        <View style={styles.loginContainer}>
          <Text style={styles.loginText}>¿Ya tienes cuenta?</Text>
          <TouchableOpacity onPress={handleLoginPress}>
            <Text style={styles.loginLink}>Inicia sesión</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    padding: 20,
  },
  logo: {
    fontSize: 32,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 20,
    color: '#c62828',
  },
  loginContainer: {
    flexDirection: 'row',
    marginTop: 20,
    justifyContent: 'center',
  },
  loginText: {
    fontSize: 16,
    marginRight: 5,
  },
  loginLink: {
    color: '#c62828',
    fontSize: 16,
    fontWeight: 'bold',
  },
  dividerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 10,
  },
  divider: {
    flex: 1,
    height: 1,
    backgroundColor: '#ddd',
  },
  dividerText: {
    marginHorizontal: 10,
    color: '#666',
  },
});


// -----------------------------------------------

// Relative Path: features/authentication/services/authService.ts

import { firebaseAuth } from '../../../config/firebase';
import {
  LoginCredentials,
  RegisterCredentials,
  User,
  AuthProvider,
} from '../types/auth.types';
import {
  GoogleSignin,
  statusCodes,
} from '@react-native-google-signin/google-signin';
import auth from '@react-native-firebase/auth';

GoogleSignin.configure({
  webClientId:
    '508664549153-0accs7a6cr8oemjp51dco090apv7vq8e.apps.googleusercontent.com',
});

class AuthService {
  // Convertir usuario de Firebase a nuestro modelo
  private mapFirebaseUser(firebaseUser: any): User | null {
    if (!firebaseUser) return null;

    return {
      uid: firebaseUser.uid,
      email: firebaseUser.email,
      displayName: firebaseUser.displayName,
      photoURL: firebaseUser.photoURL,
      phoneNumber: firebaseUser.phoneNumber,
      emailVerified: firebaseUser.emailVerified,
      providerId: firebaseUser.providerData[0]?.providerId,
    };
  }

  // Registrar un nuevo usuario con email/password
  async register({
    email,
    password,
    displayName,
  }: RegisterCredentials): Promise<User> {
    try {
      const { user } = await firebaseAuth.createUserWithEmailAndPassword(
        email,
        password,
      );

      // Actualizar el nombre si se proporciona
      if (displayName) {
        await user.updateProfile({ displayName });
      }

      return this.mapFirebaseUser(firebaseAuth.currentUser) as User;
    } catch (error: any) {
      throw this.handleError(error);
    }
  }

  // Iniciar sesión con email/password
  async login({ email, password }: LoginCredentials): Promise<User> {
    try {
      await firebaseAuth.signInWithEmailAndPassword(email, password);
      return this.mapFirebaseUser(firebaseAuth.currentUser) as User;
    } catch (error: any) {
      throw this.handleError(error);
    }
  }

  // Iniciar sesión con Google
  async loginWithGoogle(): Promise<User> {
    try {
      await GoogleSignin.hasPlayServices();
      await GoogleSignin.signIn();
      
      const { accessToken, idToken } = await GoogleSignin.getTokens();
      
      if (!idToken) {
        throw new Error('No ID token present!');
      }

      const googleCredential = auth.GoogleAuthProvider.credential(
        idToken,
        accessToken,
      );

      const userCredential =
        await auth().signInWithCredential(googleCredential);
      // Iniciar sesión en Firebase con la credencial
      //const userCredential =
      //await firebaseAuth.signInWithCredential(googleCredential);

      return this.mapFirebaseUser(userCredential.user) as User;
    } catch (error: any) {
      console.error('Error en loginWithGoogle:', error);

      // Manejar errores específicos de Google Sign-In
      if (error.code === statusCodes.SIGN_IN_CANCELLED) {
        throw new Error('Inicio de sesión cancelado por el usuario');
      } else if (error.code === statusCodes.IN_PROGRESS) {
        throw new Error('Operación de inicio de sesión en progreso');
      } else if (error.code === statusCodes.PLAY_SERVICES_NOT_AVAILABLE) {
        throw new Error('Google Play Services no está disponible');
      }

      throw this.handleError(error);
    }
  }

  // Método genérico para iniciar sesión con cualquier proveedor
  async loginWithProvider(provider: AuthProvider): Promise<User> {
    switch (provider) {
      case 'google':
        return this.loginWithGoogle();
      case 'email':
        throw new Error(
          'Usa el método login() para iniciar sesión con email/password',
        );
      default:
        throw new Error(`Proveedor de autenticación no soportado: ${provider}`);
    }
  }

  // Cerrar sesión
  async logout(): Promise<void> {
    try {
      await firebaseAuth.signOut();
    } catch (error: any) {
      throw this.handleError(error);
    }
  }

  // Obtener el usuario actual
  getCurrentUser(): User | null {
    return this.mapFirebaseUser(firebaseAuth.currentUser);
  }

  // Restablecer contraseña
  async resetPassword(email: string): Promise<void> {
    try {
      await firebaseAuth.sendPasswordResetEmail(email);
    } catch (error: any) {
      throw this.handleError(error);
    }
  }

  // Actualizar perfil
  async updateProfile(data: {
    displayName?: string;
    photoURL?: string;
  }): Promise<User> {
    try {
      const user = firebaseAuth.currentUser;
      if (!user) throw new Error('No hay usuario autenticado');

      await user.updateProfile(data);
      return this.mapFirebaseUser(firebaseAuth.currentUser) as User;
    } catch (error: any) {
      throw this.handleError(error);
    }
  }

  // Cambiar contraseña
  async updatePassword(newPassword: string): Promise<void> {
    try {
      const user = firebaseAuth.currentUser;
      if (!user) throw new Error('No hay usuario autenticado');

      await user.updatePassword(newPassword);
    } catch (error: any) {
      throw this.handleError(error);
    }
  }

  // Verificar email
  async sendEmailVerification(): Promise<void> {
    try {
      const user = firebaseAuth.currentUser;
      if (!user) throw new Error('No hay usuario autenticado');

      await user.sendEmailVerification();
    } catch (error: any) {
      throw this.handleError(error);
    }
  }

  // Escuchar cambios en la autenticación
  onAuthStateChanged(callback: (user: User | null) => void): () => void {
    return firebaseAuth.onAuthStateChanged((firebaseUser) =>
      callback(this.mapFirebaseUser(firebaseUser)),
    );
  }

  // Manejar errores de Firebase
  private handleError(error: any): Error {
    const errorCode = error.code;
    let message = 'Ha ocurrido un error desconocido';

    switch (errorCode) {
      case 'auth/email-already-in-use':
        message = 'El correo electrónico ya está en uso';
        break;
      case 'auth/invalid-email':
        message = 'El correo electrónico no es válido';
        break;
      case 'auth/user-not-found':
      case 'auth/wrong-password':
        message = 'Credenciales incorrectas';
        break;
      case 'auth/weak-password':
        message = 'La contraseña es demasiado débil';
        break;
      case 'auth/too-many-requests':
        message = 'Demasiados intentos fallidos. Intenta más tarde';
        break;
      default:
        message = error.message || message;
    }

    return new Error(message);
  }
}

export const authService = new AuthService();


// -----------------------------------------------

// Relative Path: features/authentication/store/authStore.ts

import { create } from 'zustand';
import { persist, createJSONStorage, PersistOptions } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { authService } from '../services/authService';
import {
  AuthProvider,
  AuthState,
  LoginCredentials,
  RegisterCredentials,
} from '../types/auth.types';
import { createReactotronLogger } from '../../../../ReactotronConfig';
import { StateCreator } from 'zustand';

// Variable para almacenar la función de limpieza fuera del estado
let authUnsubscribe: (() => void) | null = null;

interface AuthStore extends AuthState {
  // Acciones
  initialize: () => Promise<void>;
  cleanup: () => void;
  login: (credentials: LoginCredentials) => Promise<void>;
  loginWithProvider: (provider: AuthProvider) => Promise<void>;
  register: (credentials: RegisterCredentials) => Promise<void>;
  logout: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
  updateProfile: (data: {
    displayName?: string;
    photoURL?: string;
  }) => Promise<void>;
  updatePassword: (newPassword: string) => Promise<void>;
  sendEmailVerification: () => Promise<void>;
  clearError: () => void;
}

// Configuración de persistencia
type AuthPersistOptions = PersistOptions<
  AuthStore,
  Pick<AuthStore, 'user' | 'isAuthenticated'>
>;

const persistOptions: AuthPersistOptions = {
  name: 'auth-storage',
  storage: createJSONStorage(() => AsyncStorage),
  partialize: (state) => ({
    user: state.user,
    isAuthenticated: state.isAuthenticated,
  }),
  // Añadir monitoreo de rehidratación
  onRehydrateStorage: () => {
    return (state, error) => {
      if (error) {
        console.error('Error al hidratar el estado de autenticación:', error);
      } else {
        console.log('Estado de autenticación hidratado correctamente');

        // Registrar en Reactotron cuando se completa la hidratación
        if (__DEV__ && state) {
          import('../../../../ReactotronConfig')
            .then(({ default: reactotron }) => {
              reactotron.display({
                name: 'ZUSTAND [AuthStore] - REHYDRATED',
                preview: 'Estado de autenticación restaurado',
                value: state,
              });
            })
            .catch(console.error);
        }
      }
    };
  },
};

// Definir el store base con tipo correcto
const createBaseAuthStore: StateCreator<AuthStore, [], []> = (set, get) => ({
  // Estado inicial
  user: null,
  isLoading: true,
  error: null,
  isAuthenticated: false,

  // Inicializar el estado de autenticación
  initialize: async () => {
    set({ isLoading: true });
    try {
      // Limpiar cualquier suscripción existente
      if (authUnsubscribe) {
        authUnsubscribe();
        authUnsubscribe = null;
      }

      // Crear nueva suscripción
      authUnsubscribe = authService.onAuthStateChanged((user) => {
        set({
          user,
          isAuthenticated: !!user,
          isLoading: false,
          error: null,
        });
      });
    } catch (error: any) {
      set({
        error: error.message,
        isLoading: false,
        isAuthenticated: false,
      });
    }
  },

  // Método para limpiar la suscripción
  cleanup: () => {
    if (authUnsubscribe) {
      authUnsubscribe();
      authUnsubscribe = null;
    }
  },

  // Iniciar sesión
  login: async (credentials: LoginCredentials) => {
    set({ isLoading: true, error: null });
    try {
      const user = await authService.login(credentials);
      set({
        user,
        isAuthenticated: true,
        isLoading: false,
        error: null,
      });
    } catch (error: any) {
      set({
        error: error.message,
        isLoading: false,
        isAuthenticated: false,
      });
      throw error;
    }
  },

  // Iniciar sesión con proveedor (Google, etc.)
  loginWithProvider: async (provider: AuthProvider) => {
    set({ isLoading: true, error: null });
    try {
      const user = await authService.loginWithProvider(provider);
      console.log('Usuario autenticado con proveedor:', user);
      set({
        user,
        isAuthenticated: true,
        isLoading: false,
        error: null,
      });
    } catch (error: any) {
      set({
        error: error.message,
        isLoading: false,
        isAuthenticated: false,
      });
      throw error;
    }
  },

  // Registrar usuario
  register: async (credentials: RegisterCredentials) => {
    set({ isLoading: true, error: null });
    try {
      const user = await authService.register(credentials);
      set({
        user,
        isAuthenticated: true,
        isLoading: false,
        error: null,
      });
    } catch (error: any) {
      set({
        error: error.message,
        isLoading: false,
        isAuthenticated: false,
      });
      throw error;
    }
  },

  // Cerrar sesión
  logout: async () => {
    set({ isLoading: true, error: null });
    try {
      await authService.logout();

      // Limpiar la suscripción al cerrar sesión
      if (authUnsubscribe) {
        authUnsubscribe();
        authUnsubscribe = null;
      }

      set({
        user: null,
        isAuthenticated: false,
        isLoading: false,
        error: null,
      });
    } catch (error: any) {
      set({
        error: error.message,
        isLoading: false,
      });
      throw error;
    }
  },

  // Restablecer contraseña
  resetPassword: async (email: string) => {
    set({ isLoading: true, error: null });
    try {
      await authService.resetPassword(email);
      set({ isLoading: false });
    } catch (error: any) {
      set({
        error: error.message,
        isLoading: false,
      });
      throw error;
    }
  },

  // Actualizar perfil
  updateProfile: async (data: { displayName?: string; photoURL?: string }) => {
    set({ isLoading: true, error: null });
    try {
      const updatedUser = await authService.updateProfile(data);
      set({
        user: updatedUser,
        isLoading: false,
        error: null,
      });
    } catch (error: any) {
      set({
        error: error.message,
        isLoading: false,
      });
      throw error;
    }
  },

  // Actualizar contraseña
  updatePassword: async (newPassword: string) => {
    set({ isLoading: true, error: null });
    try {
      await authService.updatePassword(newPassword);
      set({ isLoading: false, error: null });
    } catch (error: any) {
      set({
        error: error.message,
        isLoading: false,
      });
      throw error;
    }
  },

  // Enviar verificación de email
  sendEmailVerification: async () => {
    set({ isLoading: true, error: null });
    try {
      await authService.sendEmailVerification();
      set({ isLoading: false, error: null });
    } catch (error: any) {
      set({
        error: error.message,
        isLoading: false,
      });
      throw error;
    }
  },

  // Limpiar errores
  clearError: () => set({ error: null }),
});

// Crear el store con middleware
export const useAuthStore = create<AuthStore>()(
  persist(
    // Aplicar el middleware de Reactotron en desarrollo
    __DEV__
      ? createReactotronLogger<AuthStore>('AuthStore')(createBaseAuthStore)
      : createBaseAuthStore,
    persistOptions,
  ),
);

// Selectores
export const useAuthUser = () =>
  useAuthStore((state) => ({
    user: state.user,
    isAuthenticated: state.isAuthenticated,
  }));

export const useAuthStatus = () =>
  useAuthStore((state) => ({
    isLoading: state.isLoading,
    error: state.error,
    clearError: state.clearError,
  }));


// -----------------------------------------------

// Relative Path: features/authentication/types/auth.types.ts

export interface User {
  uid: string;
  email: string | null;
  displayName: string | null;
  photoURL: string | null;
  phoneNumber: string | null;
  emailVerified: boolean;
  providerId?: string;
}

export interface AuthState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
  isAuthenticated: boolean;
}

export interface LoginCredentials {
  email: string;
  password: string;
}

export interface RegisterCredentials extends LoginCredentials {
  displayName?: string;
}

export interface AuthFormState {
  email: string;
  password: string;
  displayName?: string;
  confirmPassword?: string;
}

export type AuthProvider = 'google' | 'email';


// -----------------------------------------------

// Relative Path: features/authentication/utils/authValidation.ts

import { AuthFormState } from '../types/auth.types';

export interface ValidationErrors {
  email?: string;
  password?: string;
  displayName?: string;
  confirmPassword?: string;
}

export const validateLoginForm = (data: AuthFormState): ValidationErrors => {
  const errors: ValidationErrors = {};

  // Validar email
  if (!data.email) {
    errors.email = 'El correo electrónico es requerido';
  } else if (!/\S+@\S+\.\S+/.test(data.email)) {
    errors.email = 'El correo electrónico no es válido';
  }

  // Validar contraseña
  if (!data.password) {
    errors.password = 'La contraseña es requerida';
  }

  return errors;
};

export const validateRegisterForm = (data: AuthFormState): ValidationErrors => {
  const errors: ValidationErrors = {};

  // Validar email
  if (!data.email) {
    errors.email = 'El correo electrónico es requerido';
  } else if (!/\S+@\S+\.\S+/.test(data.email)) {
    errors.email = 'El correo electrónico no es válido';
  }

  // Validar contraseña
  if (!data.password) {
    errors.password = 'La contraseña es requerida';
  } else if (data.password.length < 6) {
    errors.password = 'La contraseña debe tener al menos 6 caracteres';
  }

  // Validar confirmación de contraseña
  if (data.password !== data.confirmPassword) {
    errors.confirmPassword = 'Las contraseñas no coinciden';
  }

  return errors;
};

export const validateResetPasswordForm = (email: string): ValidationErrors => {
  const errors: ValidationErrors = {};

  // Validar email
  if (!email) {
    errors.email = 'El correo electrónico es requerido';
  } else if (!/\S+@\S+\.\S+/.test(email)) {
    errors.email = 'El correo electrónico no es válido';
  }

  return errors;
};


// -----------------------------------------------

// Relative Path: features/minigame/components/CountdownTimer.tsx

import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, Animated } from 'react-native';

interface CountdownTimerProps {
  timeLeft: number | null;
  totalTime: number;
  onTimeout?: () => void;
}

export const CountdownTimer: React.FC<CountdownTimerProps> = ({
  timeLeft,
  totalTime,
  onTimeout,
}) => {
  const [progress] = useState(new Animated.Value(1));
  useEffect(() => {
    if (timeLeft === null) return;

    // Calcular el progreso (entre 0 y 1)
    const currentProgress = Math.max(0, timeLeft / totalTime);

    // Animar el progreso
    Animated.timing(progress, {
      toValue: currentProgress,
      duration: 100,
      useNativeDriver: false,
    }).start();

    // Llamar a onTimeout cuando el tiempo llegue a 0
    if (timeLeft <= 0 && onTimeout) {
      onTimeout();
    }
  }, [timeLeft, totalTime, progress, onTimeout]);

  // Calcular el color de la barra según el tiempo restante
  const barColor = progress.interpolate({
    inputRange: [0, 0.3, 0.6, 1],
    outputRange: ['#f44336', '#ff9800', '#ffc107', '#4caf50'],
  });

  // Formatear el tiempo restante en segundos
  const formattedTime =
    timeLeft !== null ? Math.ceil(timeLeft / 1000).toString() : '';

  return (
    <View style={styles.container}>
      <Animated.View
        style={[
          styles.progressBar,
          {
            width: progress.interpolate({
              inputRange: [0, 1],
              outputRange: ['0%', '100%'],
            }),
            backgroundColor: barColor,
          },
        ]}
      />
      <Text style={styles.timeText}>{formattedTime}</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    height: 30,
    backgroundColor: '#e0e0e0',
    borderRadius: 15,
    overflow: 'hidden',
    position: 'relative',
  },
  progressBar: {
    height: '100%',
    position: 'absolute',
    left: 0,
    top: 0,
  },
  timeText: {
    position: 'absolute',
    width: '100%',
    textAlign: 'center',
    lineHeight: 30,
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
});


// -----------------------------------------------

// Relative Path: features/minigame/components/GameOptions.tsx

import React from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  FlatList,
} from 'react-native';
import { PokemonBasic } from '../../pokemon/types/types';

interface GameOptionsProps {
  options: PokemonBasic[];
  selectedOption?: number;
  correctOption?: number;
  onSelect: (index: number) => void;
  disabled?: boolean;
}

export const GameOptions: React.FC<GameOptionsProps> = ({
  options,
  selectedOption,
  correctOption,
  onSelect,
  disabled = false,
}) => {
  const renderOption = ({
    item,
    index,
  }: {
    item: PokemonBasic;
    index: number;
  }) => {
    // Determinar el estilo del botón según la selección y corrección
    let buttonStyle = styles.optionButton;
    let textStyle = styles.optionText;

    if (selectedOption !== undefined) {
      if (index === selectedOption) {
        if (correctOption !== undefined && index === correctOption) {
          // Opción seleccionada y correcta
          buttonStyle = [styles.optionButton, styles.correctOption];
        } else {
          // Opción seleccionada pero incorrecta
          buttonStyle = [styles.optionButton, styles.incorrectOption];
        }
      } else if (correctOption !== undefined && index === correctOption) {
        // Opción correcta pero no seleccionada
        buttonStyle = [styles.optionButton, styles.correctOption];
      }
    }

    return (
      <TouchableOpacity
        style={buttonStyle}
        onPress={() => onSelect(index)}
        disabled={disabled || selectedOption !== undefined}
      >
        <Text style={textStyle}>{item.name}</Text>
      </TouchableOpacity>
    );
  };

  return (
    <View style={styles.container}>
      <FlatList
        data={options}
        renderItem={renderOption}
        keyExtractor={(item) => item.id.toString()}
        numColumns={2}
        contentContainerStyle={styles.optionsContainer}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    marginVertical: 20,
  },
  optionsContainer: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  optionButton: {
    backgroundColor: '#f5f5f5',
    padding: 15,
    margin: 8,
    borderRadius: 8,
    minWidth: 150,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: '#ddd',
  },
  optionText: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  correctOption: {
    backgroundColor: '#4caf50',
    borderColor: '#388e3c',
  },
  incorrectOption: {
    backgroundColor: '#f44336',
    borderColor: '#d32f2f',
  },
});


// -----------------------------------------------

// Relative Path: features/minigame/components/GameResult.tsx

import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
} from 'react-native';
import { CurrentGame } from '../types/minigame.types';

interface GameResultProps {
  game: CurrentGame;
  onPlayAgain: () => void;
  onGoHome: () => void;
}

export const GameResult: React.FC<GameResultProps> = ({
  game,
  onPlayAgain,
  onGoHome,
}) => {
  // Calcular estadísticas
  const totalQuestions = game.questions.length;
  const correctAnswers = game.questions.filter((q) => {
    if (q.selectedOption === undefined) return false;
    return q.options[q.selectedOption].id === q.correctPokemon.id;
  }).length;

  const accuracy = Math.round((correctAnswers / totalQuestions) * 100);

  // Calcular tiempo total
  const totalTime =
    game.endTime && game.startTime
      ? Math.floor((game.endTime - game.startTime) / 1000)
      : 0;

  // Determinar mensaje según el rendimiento
  let message = '';
  if (accuracy >= 90) {
    message = '¡Increíble! ¡Eres un Maestro Pokémon!';
  } else if (accuracy >= 70) {
    message = '¡Muy bien! Estás en camino a ser un gran entrenador.';
  } else if (accuracy >= 50) {
    message = 'Buen intento. Sigue practicando para mejorar.';
  } else {
    message = 'Necesitas estudiar más sobre Pokémon. ¡No te rindas!';
  }

  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Resultado Final</Text>

      <View style={styles.scoreContainer}>
        <Text style={styles.scoreText}>{game.score}</Text>
        <Text style={styles.scoreLabel}>Puntos</Text>
      </View>

      <Text style={styles.message}>{message}</Text>

      <View style={styles.statsContainer}>
        <View style={styles.statItem}>
          <Text style={styles.statValue}>
            {correctAnswers}/{totalQuestions}
          </Text>
          <Text style={styles.statLabel}>Correctas</Text>
        </View>

        <View style={styles.statItem}>
          <Text style={styles.statValue}>{accuracy}%</Text>
          <Text style={styles.statLabel}>Precisión</Text>
        </View>

        <View style={styles.statItem}>
          <Text style={styles.statValue}>{totalTime}s</Text>
          <Text style={styles.statLabel}>Tiempo</Text>
        </View>
      </View>

      <View style={styles.buttonsContainer}>
        <TouchableOpacity style={styles.button} onPress={onPlayAgain}>
          <Text style={styles.buttonText}>Jugar de Nuevo</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.button, styles.homeButton]}
          onPress={onGoHome}
        >
          <Text style={styles.buttonText}>Volver al Inicio</Text>
        </TouchableOpacity>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flexGrow: 1,
    padding: 20,
    alignItems: 'center',
    justifyContent: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
  scoreContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  scoreText: {
    fontSize: 48,
    fontWeight: 'bold',
    color: '#c62828',
  },
  scoreLabel: {
    fontSize: 18,
    color: '#666',
  },
  message: {
    fontSize: 18,
    textAlign: 'center',
    marginBottom: 30,
    fontStyle: 'italic',
    color: '#333',
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: '100%',
    marginBottom: 40,
  },
  statItem: {
    alignItems: 'center',
  },
  statValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
  },
  statLabel: {
    fontSize: 14,
    color: '#666',
  },
  buttonsContainer: {
    width: '100%',
  },
  button: {
    backgroundColor: '#c62828',
    padding: 15,
    borderRadius: 8,
    alignItems: 'center',
    marginBottom: 15,
  },
  homeButton: {
    backgroundColor: '#333',
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
});


// -----------------------------------------------

// Relative Path: features/minigame/components/PokemonSilhouette.tsx

import React, { useState, useEffect } from 'react';
import { View, Image, StyleSheet, ActivityIndicator } from 'react-native';
import { manipulateAsync, SaveFormat } from 'expo-image-manipulator';

interface PokemonSilhouetteProps {
  imageUrl: string;
  size?: number;
  revealed?: boolean;
}

export const PokemonSilhouette: React.FC<PokemonSilhouetteProps> = ({
  imageUrl,
  size = 200,
  revealed = false,
}) => {
  const [silhouetteUri, setSilhouetteUri] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const createSilhouette = async () => {
      try {
        setIsLoading(true);

        // Manipular la imagen para crear la silueta
        const manipResult = await manipulateAsync(
          imageUrl,
          [
            {
              brightness: -1, // Oscurecer la imagen completamente
              contrast: 100, // Aumentar el contraste al máximo
            },
          ],
          { format: SaveFormat.PNG },
        );

        setSilhouetteUri(manipResult.uri);
      } catch (error) {
        console.error('Error al crear la silueta:', error);
      } finally {
        setIsLoading(false);
      }
    };

    createSilhouette();
  }, [imageUrl]);

  if (isLoading) {
    return (
      <View style={[styles.container, { width: size, height: size }]}>
        <ActivityIndicator size="large" color="#c62828" />
      </View>
    );
  }

  return (
    <View style={[styles.container, { width: size, height: size }]}>
      <Image
        source={{ uri: revealed ? imageUrl : silhouetteUri || imageUrl }}
        style={[styles.image, { width: size, height: size }]}
        resizeMode="contain"
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
    borderRadius: 10,
    overflow: 'hidden',
  },
  image: {
    width: '100%',
    height: '100%',
  },
});


// -----------------------------------------------

// Relative Path: features/minigame/components/ScoreBoard.tsx

import React from 'react';
import { View, Text, StyleSheet, FlatList } from 'react-native';
import { GameScore, GameType } from '../types/minigame.types';

interface ScoreBoardProps {
  scores: GameScore[];
  gameType?: GameType;
}

export const ScoreBoard: React.FC<ScoreBoardProps> = ({ scores, gameType }) => {
  // Filtrar puntuaciones por tipo de juego si se especifica
  const filteredScores = gameType
    ? scores.filter((score) => score.gameType === gameType)
    : scores;

  // Ordenar por puntuación (de mayor a menor)
  const sortedScores = [...filteredScores].sort((a, b) => b.score - a.score);

  // Limitar a los 10 mejores
  const topScores = sortedScores.slice(0, 10);

  // Formatear fecha
  const formatDate = (timestamp: number) => {
    const date = new Date(timestamp);
    return date.toLocaleDateString();
  };

  // Renderizar un elemento de puntuación
  const renderScoreItem = ({
    item,
    index,
  }: {
    item: GameScore;
    index: number;
  }) => (
    <View style={styles.scoreItem}>
      <Text style={styles.rank}>{index + 1}</Text>
      <Text style={styles.score}>{item.score}</Text>
      <Text style={styles.accuracy}>
        {Math.round((item.score / (item.totalQuestions * 100)) * 100)}%
      </Text>
      <Text style={styles.date}>{formatDate(item.date)}</Text>
    </View>
  );

  // Renderizar el encabezado de la tabla
  const renderHeader = () => (
    <View style={styles.headerRow}>
      <Text style={styles.headerText}>#</Text>
      <Text style={styles.headerText}>Puntos</Text>
      <Text style={styles.headerText}>Precisión</Text>
      <Text style={styles.headerText}>Fecha</Text>
    </View>
  );

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Mejores Puntuaciones</Text>

      {topScores.length > 0 ? (
        <FlatList
          data={topScores}
          renderItem={renderScoreItem}
          keyExtractor={(item) => item.id}
          ListHeaderComponent={renderHeader}
          contentContainerStyle={styles.listContent}
        />
      ) : (
        <Text style={styles.emptyText}>
          Aún no hay puntuaciones registradas. ¡Juega para ser el primero!
        </Text>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
  listContent: {
    paddingBottom: 20,
  },
  headerRow: {
    flexDirection: 'row',
    paddingVertical: 10,
    borderBottomWidth: 2,
    borderBottomColor: '#ddd',
    marginBottom: 5,
  },
  headerText: {
    fontWeight: 'bold',
    fontSize: 16,
    color: '#333',
    flex: 1,
    textAlign: 'center',
  },
  scoreItem: {
    flexDirection: 'row',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  rank: {
    flex: 0.5,
    fontWeight: 'bold',
    fontSize: 16,
    textAlign: 'center',
  },
  score: {
    flex: 1,
    fontSize: 16,
    textAlign: 'center',
    color: '#c62828',
    fontWeight: 'bold',
  },
  accuracy: {
    flex: 1,
    fontSize: 16,
    textAlign: 'center',
  },
  date: {
    flex: 1.5,
    fontSize: 14,
    textAlign: 'center',
    color: '#666',
  },
  emptyText: {
    textAlign: 'center',
    marginTop: 30,
    fontSize: 16,
    color: '#666',
    fontStyle: 'italic',
  },
});


// -----------------------------------------------

// Relative Path: features/minigame/hooks/useGameSound.ts

import { useEffect, useState } from 'react';
import { Audio } from 'expo-av';
import { useMinigameStore } from '../store/minigameStore';

export const useGameSound = () => {
  const { soundEnabled } = useMinigameStore();
  const [sounds, setSounds] = useState<Record<string, Audio.Sound | null>>({
    correct: null,
    incorrect: null,
    gameOver: null,
    background: null,
  });

  // Cargar sonidos
  useEffect(() => {
    const loadSounds = async () => {
      try {
        // Cargar sonidos
        const correctSound = new Audio.Sound();
        await correctSound.loadAsync(
          require('../../../../assets/sounds/correct.mp3'),
        );

        const incorrectSound = new Audio.Sound();
        await incorrectSound.loadAsync(
          require('../../../../assets/sounds/incorrect.mp3'),
        );

        const gameOverSound = new Audio.Sound();
        await gameOverSound.loadAsync(
          require('../../../../assets/sounds/game-over.mp3'),
        );

        const backgroundSound = new Audio.Sound();
        await backgroundSound.loadAsync(
          require('../../../../assets/sounds/background.mp3'),
        );

        // Configurar el sonido de fondo para que se repita
        await backgroundSound.setIsLoopingAsync(true);
        // Bajar el volumen del sonido de fondo
        await backgroundSound.setVolumeAsync(0.3);

        setSounds({
          correct: correctSound,
          incorrect: incorrectSound,
          gameOver: gameOverSound,
          background: backgroundSound,
        });
      } catch (error) {
        console.error('Error al cargar los sonidos:', error);
      }
    };

    loadSounds();

    // Limpiar sonidos al desmontar
    return () => {
      Object.values(sounds).forEach(async (sound) => {
        if (sound) {
          await sound.unloadAsync();
        }
      });
    };
  }, []);

  // Reproducir sonido de respuesta correcta
  const playCorrect = async () => {
    if (soundEnabled && sounds.correct) {
      try {
        await sounds.correct.replayAsync();
      } catch (error) {
        console.error('Error al reproducir sonido correcto:', error);
      }
    }
  };

  // Reproducir sonido de respuesta incorrecta
  const playIncorrect = async () => {
    if (soundEnabled && sounds.incorrect) {
      try {
        await sounds.incorrect.replayAsync();
      } catch (error) {
        console.error('Error al reproducir sonido incorrecto:', error);
      }
    }
  };

  // Reproducir sonido de fin de juego
  const playGameOver = async () => {
    if (soundEnabled && sounds.gameOver) {
      try {
        await sounds.gameOver.replayAsync();
      } catch (error) {
        console.error('Error al reproducir sonido de fin de juego:', error);
      }
    }
  };

  // Iniciar música de fondo
  const startBackgroundMusic = async () => {
    if (soundEnabled && sounds.background) {
      try {
        await sounds.background.playAsync();
      } catch (error) {
        console.error('Error al reproducir música de fondo:', error);
      }
    }
  };

  // Detener música de fondo
  const stopBackgroundMusic = async () => {
    if (sounds.background) {
      try {
        await sounds.background.stopAsync();
      } catch (error) {
        console.error('Error al detener música de fondo:', error);
      }
    }
  };

  // Pausar/reanudar música de fondo según el estado de soundEnabled
  useEffect(() => {
    if (sounds.background) {
      if (soundEnabled) {
        sounds.background.playAsync().catch(console.error);
      } else {
        sounds.background.pauseAsync().catch(console.error);
      }
    }
  }, [soundEnabled, sounds.background]);

  return {
    playCorrect,
    playIncorrect,
    playGameOver,
    startBackgroundMusic,
    stopBackgroundMusic,
  };
};


// -----------------------------------------------

// Relative Path: features/minigame/hooks/useMinigame.ts

import { useState, useEffect, useCallback, useRef } from 'react';
import { useMinigameStore } from '../store/minigameStore';
import { GameConfig, GameStatus } from '../types/minigame.types';
import { useGameSound } from './useGameSound';

export const useMinigame = (config?: GameConfig) => {
  const {
    currentGame,
    isLoading,
    error,
    startGame,
    answerQuestion,
    nextQuestion,
    endGame,
    resetGame,
  } = useMinigameStore();

  const { playCorrect, playIncorrect, playGameOver } = useGameSound();

  // Estado local para el temporizador
  const [timeLeft, setTimeLeft] = useState<number | null>(null);
  const [questionStartTime, setQuestionStartTime] = useState<number | null>(
    null,
  );

  // Referencia para el intervalo del temporizador
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  // Iniciar el juego
  const handleStartGame = useCallback(
    async (gameConfig: GameConfig) => {
      await startGame(gameConfig);
      setQuestionStartTime(Date.now());
    },
    [startGame],
  );
  const handleAnswerQuestion = useCallback(
    (optionIndex: number) => {
      if (!currentGame || !questionStartTime) return;

      // Calcular el tiempo que tomó responder
      const timeSpent = Date.now() - questionStartTime;

      // Registrar la respuesta
      answerQuestion(currentGame.currentQuestionIndex, optionIndex, timeSpent);

      // Detener el temporizador
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }

      // Reproducir sonido según la respuesta
      const currentQuestion =
        currentGame.questions[currentGame.currentQuestionIndex];
      const isCorrect =
        currentQuestion.options[optionIndex].id ===
        currentQuestion.correctPokemon.id;

      if (isCorrect) {
        playCorrect();
      } else {
        playIncorrect();
      }
    },
    [
      currentGame,
      questionStartTime,
      answerQuestion,
      playCorrect,
      playIncorrect,
    ],
  );

  // Avanzar a la siguiente pregunta
  const handleNextQuestion = useCallback(() => {
    nextQuestion();
    setQuestionStartTime(Date.now());
  }, [nextQuestion]);

  // Finalizar el juego
  const handleEndGame = useCallback(() => {
    endGame();
    playGameOver();

    // Detener el temporizador
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }
  }, [endGame, playGameOver]);

  // Reiniciar el juego
  const handleResetGame = useCallback(() => {
    resetGame();

    // Detener el temporizador
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }
  }, [resetGame]);

  // Gestionar el temporizador
  useEffect(() => {
    // Iniciar temporizador solo si hay un juego en progreso y tiene límite de tiempo
    if (
      currentGame?.status === GameStatus.IN_PROGRESS &&
      config?.timeLimit &&
      questionStartTime
    ) {
      // Convertir a milisegundos
      const timeLimitMs = config.timeLimit * 1000;
      setTimeLeft(timeLimitMs);

      timerRef.current = setInterval(() => {
        const elapsed = Date.now() - questionStartTime;
        const remaining = timeLimitMs - elapsed;

        if (remaining <= 0) {
          // Se acabó el tiempo, seleccionar una respuesta aleatoria o considerar como incorrecta
          const randomOption = Math.floor(
            Math.random() *
              currentGame.questions[currentGame.currentQuestionIndex].options
                .length,
          );
          handleAnswerQuestion(randomOption);

          // Detener el temporizador
          if (timerRef.current) {
            clearInterval(timerRef.current);
            timerRef.current = null;
          }
        } else {
          setTimeLeft(remaining);
        }
      }, 100); // Actualizar cada 100ms para una cuenta regresiva suave

      return () => {
        if (timerRef.current) {
          clearInterval(timerRef.current);
          timerRef.current = null;
        }
      };
    }
  }, [currentGame, config, questionStartTime, handleAnswerQuestion]);

  // Limpiar al desmontar
  useEffect(() => {
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, []);

  // Obtener la pregunta actual
  const currentQuestion = currentGame
    ? currentGame.questions[currentGame.currentQuestionIndex]
    : null;

  // Calcular progreso del juego
  const progress = currentGame
    ? (currentGame.currentQuestionIndex + 1) / currentGame.questions.length
    : 0;

  return {
    // Estado
    currentGame,
    currentQuestion,
    isLoading,
    error,
    timeLeft,
    progress,

    // Acciones
    startGame: handleStartGame,
    answerQuestion: handleAnswerQuestion,
    nextQuestion: handleNextQuestion,
    endGame: handleEndGame,
    resetGame: handleResetGame,
  };
};


// -----------------------------------------------

// Relative Path: features/minigame/index.ts

export { PokemonSilhouette } from './components/PokemonSilhouette';
export { GameOptions } from './components/GameOptions';
export { CountdownTimer } from './components/CountdownTimer';
export { GameResult } from './components/GameResult';
export { ScoreBoard } from './components/ScoreBoard';

// Pantallas
export { MinigameHomeScreen } from './screens/MinigameHomeScreen';
export { WhosThatPokemonScreen } from './screens/WhosThatPokemonScreen';

// Hooks
export { useMinigame } from './hooks/useMinigame';
export { useGameSound } from './hooks/useGameSound';

// Store
export { useMinigameStore } from './store/minigameStore';

// Tipos
export { GameType, GameStatus, GameDifficulty } from './types/minigame.types';

// Utilidades
export * from './utils/gameUtils';


// -----------------------------------------------

// Relative Path: features/minigame/screens/MinigameHomeScreen.tsx

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Switch,
  Image,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { MaterialIcons } from '@expo/vector-icons';
import { ScoreBoard } from '../components/ScoreBoard';
import { useMinigameStore } from '../store/minigameStore';
import { GameType, GameDifficulty } from '../types/minigame.types';

export const MinigameHomeScreen: React.FC = () => {
  const navigation = useNavigation();
  const { scores, soundEnabled, toggleSound } = useMinigameStore();

  // Estado para la configuración del juego
  const [selectedGameType, setSelectedGameType] = useState(
    GameType.WHOS_THAT_POKEMON,
  );
  const [selectedDifficulty, setSelectedDifficulty] = useState(
    GameDifficulty.MEDIUM,
  );
  const [questionCount, setQuestionCount] = useState(10);

  // Iniciar el juego
  const handleStartGame = () => {
    navigation.navigate('WhosThatPokemon', {
      gameType: selectedGameType,
      difficulty: selectedDifficulty,
      questionCount,
    });
  };

  return (
    <ScrollView style={styles.container}>
      <View style={styles.header}>
        <Image
          source={require('../../../../assets/minigame-logo.png')}
          style={styles.logo}
          resizeMode="contain"
        />
        <Text style={styles.subtitle}>
          ¡Pon a prueba tus conocimientos Pokémon!
        </Text>
      </View>

      <View style={styles.configSection}>
        <Text style={styles.sectionTitle}>Configuración del Juego</Text>

        <View style={styles.configItem}>
          <Text style={styles.configLabel}>Tipo de Juego</Text>
          <View style={styles.gameTypeContainer}>
            <TouchableOpacity
              style={[
                styles.gameTypeButton,
                selectedGameType === GameType.WHOS_THAT_POKEMON &&
                  styles.selectedButton,
              ]}
              onPress={() => setSelectedGameType(GameType.WHOS_THAT_POKEMON)}
            >
              <Text style={styles.gameTypeText}>¿Quién es ese Pokémon?</Text>
            </TouchableOpacity>
            {/* Más tipos de juego se pueden añadir aquí en el futuro */}
          </View>
        </View>

        <View style={styles.configItem}>
          <Text style={styles.configLabel}>Dificultad</Text>
          <View style={styles.difficultyContainer}>
            <TouchableOpacity
              style={[
                styles.difficultyButton,
                selectedDifficulty === GameDifficulty.EASY && styles.easyButton,
                selectedDifficulty === GameDifficulty.EASY &&
                  styles.selectedButton,
              ]}
              onPress={() => setSelectedDifficulty(GameDifficulty.EASY)}
            >
              <Text style={styles.difficultyText}>Fácil</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.difficultyButton,
                selectedDifficulty === GameDifficulty.MEDIUM &&
                  styles.mediumButton,
                selectedDifficulty === GameDifficulty.MEDIUM &&
                  styles.selectedButton,
              ]}
              onPress={() => setSelectedDifficulty(GameDifficulty.MEDIUM)}
            >
              <Text style={styles.difficultyText}>Medio</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.difficultyButton,
                selectedDifficulty === GameDifficulty.HARD && styles.hardButton,
                selectedDifficulty === GameDifficulty.HARD &&
                  styles.selectedButton,
              ]}
              onPress={() => setSelectedDifficulty(GameDifficulty.HARD)}
            >
              <Text style={styles.difficultyText}>Difícil</Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.configItem}>
          <Text style={styles.configLabel}>Número de Preguntas</Text>
          <View style={styles.questionCountContainer}>
            <TouchableOpacity
              style={[
                styles.questionCountButton,
                questionCount === 5 && styles.selectedButton,
              ]}
              onPress={() => setQuestionCount(5)}
            >
              <Text style={styles.questionCountText}>5</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.questionCountButton,
                questionCount === 10 && styles.selectedButton,
              ]}
              onPress={() => setQuestionCount(10)}
            >
              <Text style={styles.questionCountText}>10</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.questionCountButton,
                questionCount === 20 && styles.selectedButton,
              ]}
              onPress={() => setQuestionCount(20)}
            >
              <Text style={styles.questionCountText}>20</Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.configItem}>
          <Text style={styles.configLabel}>Sonido</Text>
          <Switch
            value={soundEnabled}
            onValueChange={toggleSound}
            trackColor={{ false: '#767577', true: '#c62828' }}
            thumbColor={soundEnabled ? '#f5dd4b' : '#f4f3f4'}
          />
        </View>
      </View>

      <TouchableOpacity style={styles.startButton} onPress={handleStartGame}>
        <Text style={styles.startButtonText}>¡Comenzar Juego!</Text>
        <MaterialIcons name="play-arrow" size={24} color="white" />
      </TouchableOpacity>

      <ScoreBoard scores={scores} gameType={selectedGameType} />
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    alignItems: 'center',
    paddingVertical: 20,
    paddingHorizontal: 16,
  },
  logo: {
    width: 250,
    height: 100,
    marginBottom: 10,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  configSection: {
    backgroundColor: 'white',
    margin: 16,
    borderRadius: 10,
    padding: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 16,
    color: '#333',
  },
  configItem: {
    marginBottom: 20,
  },
  configLabel: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 8,
    color: '#555',
  },
  gameTypeContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  gameTypeButton: {
    backgroundColor: '#f0f0f0',
    padding: 12,
    borderRadius: 8,
    marginRight: 10,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: '#ddd',
  },
  gameTypeText: {
    fontSize: 14,
    color: '#333',
  },
  difficultyContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  difficultyButton: {
    flex: 1,
    padding: 12,
    alignItems: 'center',
    borderRadius: 8,
    marginHorizontal: 5,
    borderWidth: 1,
    borderColor: '#ddd',
  },
  easyButton: {
    backgroundColor: '#a5d6a7',
  },
  mediumButton: {
    backgroundColor: '#fff59d',
  },
  hardButton: {
    backgroundColor: '#ef9a9a',
  },
  difficultyText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
  },
  questionCountContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  questionCountButton: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: '#f0f0f0',
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: '#ddd',
  },
  questionCountText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  selectedButton: {
    borderColor: '#c62828',
    borderWidth: 2,
    backgroundColor: 'rgba(198, 40, 40, 0.1)',
  },
  startButton: {
    backgroundColor: '#c62828',
    margin: 16,
    padding: 16,
    borderRadius: 8,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  startButtonText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
    marginRight: 8,
  },
});


// -----------------------------------------------

// Relative Path: features/minigame/screens/WhosThatPokemonScreen.tsx

import React, { useEffect, useMemo, useRef, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  SafeAreaView,
  Alert,
  BackHandler,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { MaterialIcons } from '@expo/vector-icons';
import { PokemonSilhouette } from '../components/PokemonSilhouette';
import { GameOptions } from '../components/GameOptions';
import { CountdownTimer } from '../components/CountdownTimer';
import { GameResult } from '../components/GameResult';
import { useMinigame } from '../hooks/useMinigame';
import { GameStatus, GameType, GameDifficulty } from '../types/minigame.types';
import { MainNavigationProp, MainRouteProp } from '../../../navigation/types';

export const WhosThatPokemonScreen: React.FC = () => {
  const navigation = useNavigation<MainNavigationProp<'WhosThatPokemon'>>();
  const route = useRoute<MainRouteProp<'WhosThatPokemon'>>();
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  const { gameType, difficulty, questionCount } = route.params;

  // Configuración del juego
  const gameConfig = useMemo(
    () => ({
      gameType: gameType || GameType.WHOS_THAT_POKEMON,
      difficulty: difficulty || GameDifficulty.MEDIUM,
      questionCount: questionCount || 10,
      timeLimit: getTimeLimitForDifficulty(difficulty),
    }),
    [gameType, difficulty, questionCount],
  );

  // Usar el hook del minijuego
  const {
    currentGame,
    currentQuestion,
    isLoading,
    error,
    timeLeft,
    startGame,
    answerQuestion,
    nextQuestion,
    resetGame,
  } = useMinigame(gameConfig);

  // Estado para controlar la revelación de la respuesta
  const [revealed, setRevealed] = useState(false);

  // Iniciar el juego al montar el componente
  useEffect(() => {
    startGame(gameConfig);

    // Manejar el botón de retroceso
    const handleBackPress = () => {
      if (currentGame?.status === GameStatus.IN_PROGRESS) {
        Alert.alert(
          'Salir del juego',
          '¿Estás seguro de que quieres salir? Perderás tu progreso actual.',
          [
            { text: 'Cancelar', style: 'cancel', onPress: () => {} },
            {
              text: 'Salir',
              style: 'destructive',
              onPress: () => {
                resetGame();
                navigation.goBack();
              },
            },
          ],
        );
        return true; // Prevenir el comportamiento por defecto
      }
      return false; // Permitir el comportamiento por defecto
    };

    // Añadir listener para el botón de retroceso (Android)
    const backHandler = BackHandler.addEventListener(
      'hardwareBackPress',
      handleBackPress,
    );

    // Limpiar al desmontar
    return () => {
      backHandler.remove();
    };
  }, []);

  // Manejar la selección de una opción
  const handleSelectOption = (optionIndex: number) => {
    answerQuestion(optionIndex);
    setRevealed(true);

    if (timerRef.current) clearTimeout(timerRef.current);

    timerRef.current = setTimeout(() => {
      if (
        currentGame?.currentQuestionIndex ===
        (currentGame?.questions.length ?? 0) - 1
      ) {
        // Si es la última pregunta, no avanzar automáticamente
      } else {
        handleNextQuestion();
      }
    }, 2000);
  };

  useEffect(() => {
    return () => {
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, []);

  // Pasar a la siguiente pregunta
  const handleNextQuestion = () => {
    setRevealed(false);
    nextQuestion();
  };

  // Volver a la pantalla de inicio
  const handleGoHome = () => {
    resetGame();
    navigation.goBack();
  };

  // Jugar de nuevo
  const handlePlayAgain = () => {
    resetGame();
    startGame(gameConfig);
  };

  // Renderizar pantalla de carga
  if (isLoading && !currentGame) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#c62828" />
        <Text style={styles.loadingText}>Cargando juego...</Text>
      </View>
    );
  }

  // Renderizar pantalla de error
  if (error && !currentGame) {
    return (
      <View style={styles.errorContainer}>
        <MaterialIcons name="error" size={48} color="#c62828" />
        <Text style={styles.errorText}>{error}</Text>
        <TouchableOpacity style={styles.button} onPress={handleGoHome}>
          <Text style={styles.buttonText}>Volver al Inicio</Text>
        </TouchableOpacity>
      </View>
    );
  }

  // Renderizar resultado final
  if (currentGame?.status === GameStatus.COMPLETED) {
    return (
      <SafeAreaView style={styles.container}>
        <GameResult
          game={currentGame}
          onPlayAgain={handlePlayAgain}
          onGoHome={handleGoHome}
        />
      </SafeAreaView>
    );
  }

  // Renderizar el juego
  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.questionText}>
          Pregunta{' '}
          {currentGame?.currentQuestionIndex !== undefined
            ? currentGame.currentQuestionIndex + 1
            : 0}{' '}
          de {currentGame?.questions.length || 0}
        </Text>
        <Text style={styles.scoreText}>
          Puntuación: {currentGame?.score || 0}
        </Text>
      </View>

      {gameConfig.timeLimit && (
        <CountdownTimer
          timeLeft={timeLeft}
          totalTime={gameConfig.timeLimit * 1000}
          onTimeout={() => {
            // Seleccionar una opción aleatoria al acabar el tiempo
            if (currentQuestion && !currentQuestion.answered) {
              const randomOption = Math.floor(
                Math.random() * currentQuestion.options.length,
              );
              handleSelectOption(randomOption);
            }
          }}
        />
      )}

      <View style={styles.gameContent}>
        <Text style={styles.title}>¿Quién es ese Pokémon?</Text>

        {currentQuestion && (
          <>
            <PokemonSilhouette
              imageUrl={currentQuestion.correctPokemon.imageUrl}
              size={200}
              revealed={revealed}
            />

            <GameOptions
              options={currentQuestion.options}
              selectedOption={currentQuestion.selectedOption}
              correctOption={currentQuestion.options.findIndex(
                (option) => option.id === currentQuestion.correctPokemon.id,
              )}
              onSelect={handleSelectOption}
              disabled={currentQuestion.answered}
            />

            {currentQuestion.answered && (
              <View style={styles.resultContainer}>
                <Text style={styles.resultText}>
                  {currentQuestion.options[currentQuestion.selectedOption!]
                    .id === currentQuestion.correctPokemon.id
                    ? '¡Correcto!'
                    : '¡Incorrecto!'}
                </Text>
                <Text style={styles.pokemonName}>
                  Es {currentQuestion.correctPokemon.name}
                </Text>

                {currentGame?.currentQuestionIndex ===
                (currentGame?.questions.length ?? 0) - 1 ? (
                  <TouchableOpacity
                    style={styles.nextButton}
                    onPress={() =>
                      currentGame.endTime
                        ? handlePlayAgain()
                        : handleNextQuestion()
                    }
                  >
                    <Text style={styles.nextButtonText}>
                      {currentGame.endTime ? 'Ver Resultados' : 'Siguiente'}
                    </Text>
                    <MaterialIcons
                      name={currentGame.endTime ? 'score' : 'arrow-forward'}
                      size={24}
                      color="white"
                    />
                  </TouchableOpacity>
                ) : (
                  <TouchableOpacity
                    style={styles.nextButton}
                    onPress={handleNextQuestion}
                  >
                    <Text style={styles.nextButtonText}>Siguiente</Text>
                    <MaterialIcons
                      name="arrow-forward"
                      size={24}
                      color="white"
                    />
                  </TouchableOpacity>
                )}
              </View>
            )}
          </>
        )}
      </View>
    </SafeAreaView>
  );
};

// Función para determinar el límite de tiempo según la dificultad
const getTimeLimitForDifficulty = (difficulty?: GameDifficulty): number => {
  switch (difficulty) {
    case GameDifficulty.EASY:
      return 15; // 15 segundos
    case GameDifficulty.MEDIUM:
      return 10; // 10 segundos
    case GameDifficulty.HARD:
      return 5; // 5 segundos
    default:
      return 10; // Por defecto, 10 segundos
  }
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#666',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
    padding: 20,
  },
  errorText: {
    marginTop: 10,
    marginBottom: 20,
    fontSize: 16,
    color: '#c62828',
    textAlign: 'center',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    backgroundColor: 'white',
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
  },
  questionText: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  scoreText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#c62828',
  },
  gameContent: {
    flex: 1,
    padding: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 30,
    textAlign: 'center',
    color: '#333',
  },
  resultContainer: {
    alignItems: 'center',
    marginTop: 20,
  },
  resultText: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 10,
    color: '#4caf50',
  },
  pokemonName: {
    fontSize: 20,
    marginBottom: 20,
    color: '#333',
  },
  nextButton: {
    backgroundColor: '#c62828',
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    flexDirection: 'row',
    alignItems: 'center',
  },
  nextButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
    marginRight: 8,
  },
  button: {
    backgroundColor: '#c62828',
    padding: 15,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 20,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
});


// -----------------------------------------------

// Relative Path: features/minigame/services/minigameService.ts

import { pokemonRepository } from '../../pokemon/services/api';
import { PokemonBasic } from '../../pokemon/types/types';
import {
  GameConfig,
  GameQuestion,
  GameType,
  GameDifficulty,
} from '../types/minigame.types';

// Suponemos que ya tienes un servicio o repositorio para obtener Pokémon

class MinigameService {
  // Crear un nuevo juego basado en la configuración
  async createGame(config: GameConfig): Promise<GameQuestion[]> {
    try {
      // Obtener una lista de Pokémon para el juego
      const { results: pokemonList } = await pokemonRepository.getList(100, 0);

      // Crear preguntas según el tipo de juego
      switch (config.gameType) {
        case GameType.WHOS_THAT_POKEMON:
          return this.createWhosThatPokemonGame(pokemonList, config);
        default:
          throw new Error(`Tipo de juego no implementado: ${config.gameType}`);
      }
    } catch (error) {
      console.error('Error al crear el juego:', error);
      throw error;
    }
  }

  // Crear juego específico: ¿Quién es ese Pokémon?
  private createWhosThatPokemonGame(
    pokemonList: PokemonBasic[],
    config: GameConfig,
  ): GameQuestion[] {
    // Barajar la lista de Pokémon
    const shuffledPokemon = this.shuffleArray([...pokemonList]);

    // Determinar número de opciones según dificultad
    let optionsCount = 4;
    switch (config.difficulty) {
      case GameDifficulty.EASY:
        optionsCount = 3;
        break;
      case GameDifficulty.MEDIUM:
        optionsCount = 4;
        break;
      case GameDifficulty.HARD:
        optionsCount = 6;
        break;
    }

    // Crear las preguntas
    const questions: GameQuestion[] = [];

    for (let i = 0; i < config.questionCount; i++) {
      // Asegurarse de que tenemos suficientes Pokémon
      if (i >= shuffledPokemon.length) break;

      // Seleccionar el Pokémon correcto para esta pregunta
      const correctPokemon = shuffledPokemon[i];

      // Crear opciones (incluyendo la correcta)
      const options = this.generateOptions(
        correctPokemon,
        shuffledPokemon,
        optionsCount,
      );

      // Crear la pregunta
      questions.push({
        id: i + 1,
        correctPokemon,
        options,
        answered: false,
      });
    }

    return questions;
  }

  // Generar opciones para una pregunta
  private generateOptions(
    correctPokemon: PokemonBasic,
    allPokemon: PokemonBasic[],
    count: number,
  ): PokemonBasic[] {
    // Filtrar el Pokémon correcto de la lista completa
    const otherPokemon = allPokemon.filter((p) => p.id !== correctPokemon.id);

    // Barajar los Pokémon restantes
    const shuffledOthers = this.shuffleArray(otherPokemon);

    // Tomar count-1 Pokémon incorrectos
    const incorrectOptions = shuffledOthers.slice(0, count - 1);

    // Combinar con el Pokémon correcto
    const allOptions = [...incorrectOptions, correctPokemon];

    // Barajar las opciones para que la correcta no esté siempre en la misma posición
    return this.shuffleArray(allOptions);
  }

  // Barajar un array (algoritmo de Fisher-Yates)
  private shuffleArray<T>(array: T[]): T[] {
    const result = [...array];
    for (let i = result.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
  }

  // Calcular puntuación para una pregunta
  calculateQuestionScore(
    timeSpent: number,
    maxTime: number,
    difficulty: GameDifficulty,
  ): number {
    // Base score
    let baseScore = 100;

    // Ajustar según dificultad
    switch (difficulty) {
      case GameDifficulty.EASY:
        baseScore = 50;
        break;
      case GameDifficulty.MEDIUM:
        baseScore = 100;
        break;
      case GameDifficulty.HARD:
        baseScore = 150;
        break;
    }

    // Bonus por tiempo (más rápido = más puntos)
    const timeRatio = 1 - Math.min(timeSpent / maxTime, 1);
    const timeBonus = Math.floor(baseScore * 0.5 * timeRatio);

    return baseScore + timeBonus;
  }
}

export const minigameService = new MinigameService();


// -----------------------------------------------

// Relative Path: features/minigame/store/minigameStore.ts

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
import {
  MinigameState,
  GameScore,
  CurrentGame,
  GameStatus,
  GameConfig,
} from '../types/minigame.types';
import { minigameService } from '../services/minigameService';

interface MinigameStore extends MinigameState {
  // Acciones
  startGame: (config: GameConfig) => Promise<void>;
  answerQuestion: (
    questionIndex: number,
    optionIndex: number,
    timeSpent: number,
  ) => void;
  nextQuestion: () => void;
  endGame: () => void;
  resetGame: () => void;
  toggleSound: () => void;
  setLoading: (isLoading: boolean) => void;
  setError: (error: string | null) => void;
  clearError: () => void;
}

export const useMinigameStore = create<MinigameStore>()(
  persist(
    (set, get) => ({
      // Estado inicial
      scores: [],
      currentGame: null,
      isLoading: false,
      error: null,
      soundEnabled: true,

      // Acciones
      startGame: async (config: GameConfig) => {
        set({ isLoading: true, error: null });
        try {
          const questions = await minigameService.createGame(config);

          const currentGame: CurrentGame = {
            gameType: config.gameType,
            questions,
            currentQuestionIndex: 0,
            score: 0,
            startTime: Date.now(),
            status: GameStatus.IN_PROGRESS,
          };

          set({ currentGame, isLoading: false });
        } catch (error) {
          set({
            error:
              error instanceof Error
                ? error.message
                : 'Error al iniciar el juego',
            isLoading: false,
          });
        }
      },

      answerQuestion: (
        questionIndex: number,
        optionIndex: number,
        timeSpent: number,
      ) => {
        const { currentGame } = get();
        if (!currentGame) return;

        const updatedQuestions = [...currentGame.questions];
        const question = updatedQuestions[questionIndex];

        // Actualizar la pregunta con la respuesta seleccionada
        updatedQuestions[questionIndex] = {
          ...question,
          answered: true,
          selectedOption: optionIndex,
          timeSpent,
        };

        // Verificar si la respuesta es correcta
        const isCorrect =
          question.options[optionIndex].id === question.correctPokemon.id;

        // Calcular puntuación
        let additionalScore = 0;
        if (isCorrect) {
          // Suponemos un tiempo máximo de 10 segundos por pregunta
          additionalScore = minigameService.calculateQuestionScore(
            timeSpent,
            10000, // 10 segundos en milisegundos
            // Asumimos dificultad media por defecto
            'MEDIUM',
          );
        }

        // Actualizar el juego actual
        set({
          currentGame: {
            ...currentGame,
            questions: updatedQuestions,
            score: currentGame.score + additionalScore,
          },
        });
      },

      nextQuestion: () => {
        const { currentGame } = get();
        if (!currentGame) return;

        const nextIndex = currentGame.currentQuestionIndex + 1;

        // Verificar si hemos llegado al final del juego
        if (nextIndex >= currentGame.questions.length) {
          // Finalizar el juego
          get().endGame();
          return;
        }

        // Avanzar a la siguiente pregunta
        set({
          currentGame: {
            ...currentGame,
            currentQuestionIndex: nextIndex,
          },
        });
      },

      endGame: () => {
        const { currentGame } = get();
        if (!currentGame) return;

        // Marcar el juego como completado
        const completedGame: CurrentGame = {
          ...currentGame,
          endTime: Date.now(),
          status: GameStatus.COMPLETED,
        };

        // Crear un registro de puntuación
        const newScore: GameScore = {
          id: Date.now().toString(),
          date: Date.now(),
          score: completedGame.score,
          totalQuestions: completedGame.questions.length,
          gameType: completedGame.gameType,
        };

        // Actualizar el estado
        set((state) => ({
          currentGame: completedGame,
          scores: [...state.scores, newScore],
        }));
      },

      resetGame: () => {
        set({ currentGame: null });
      },

      toggleSound: () => {
        set((state) => ({ soundEnabled: !state.soundEnabled }));
      },

      setLoading: (isLoading: boolean) => {
        set({ isLoading });
      },

      setError: (error: string | null) => {
        set({ error });
      },

      clearError: () => {
        set({ error: null });
      },
    }),
    {
      name: 'minigame-storage',
      storage: createJSONStorage(() => AsyncStorage),
      partialize: (state) => ({
        scores: state.scores,
        soundEnabled: state.soundEnabled,
      }),
    },
  ),
);


// -----------------------------------------------

// Relative Path: features/minigame/types/minigame.types.ts

import { PokemonBasic } from '../../pokemon/types/types';

export interface MinigameState {
  scores: GameScore[];
  currentGame: CurrentGame | null;
  isLoading: boolean;
  error: string | null;
  soundEnabled: boolean;
}

export interface GameScore {
  id: string;
  date: number;
  score: number;
  totalQuestions: number;
  gameType: GameType;
}

export interface CurrentGame {
  gameType: GameType;
  questions: GameQuestion[];
  currentQuestionIndex: number;
  score: number;
  startTime: number;
  endTime?: number;
  status: GameStatus;
}

export interface GameQuestion {
  id: number;
  correctPokemon: PokemonBasic;
  options: PokemonBasic[];
  answered: boolean;
  selectedOption?: number;
  timeSpent?: number;
}

export enum GameType {
  WHOS_THAT_POKEMON = 'WHOS_THAT_POKEMON',
  POKEMON_TYPES = 'POKEMON_TYPES',
  POKEMON_ABILITIES = 'POKEMON_ABILITIES',
}

export enum GameStatus {
  NOT_STARTED = 'NOT_STARTED',
  IN_PROGRESS = 'IN_PROGRESS',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
}

export enum GameDifficulty {
  EASY = 'EASY',
  MEDIUM = 'MEDIUM',
  HARD = 'HARD',
}

export interface GameConfig {
  gameType: GameType;
  questionCount: number;
  difficulty: GameDifficulty;
  timeLimit?: number; // Tiempo en segundos por pregunta, si aplica
}


// -----------------------------------------------

// Relative Path: features/minigame/utils/gameUtils.ts

import { GameDifficulty } from '../types/minigame.types';

/**
 * Baraja un array utilizando el algoritmo de Fisher-Yates
 */
export const shuffleArray = <T>(array: T[]): T[] => {
  const result = [...array];
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
};

/**
 * Calcula la puntuación para una pregunta basada en el tiempo y la dificultad
 */
export const calculateScore = (
  isCorrect: boolean,
  timeSpentMs: number,
  timeLimitMs: number,
  difficulty: GameDifficulty,
): number => {
  if (!isCorrect) return 0;

  // Puntuación base según dificultad
  let baseScore = 0;
  switch (difficulty) {
    case GameDifficulty.EASY:
      baseScore = 50;
      break;
    case GameDifficulty.MEDIUM:
      baseScore = 100;
      break;
    case GameDifficulty.HARD:
      baseScore = 150;
      break;
  }

  // Bonus por tiempo (más rápido = más puntos)
  const timeRatio = Math.max(0, 1 - timeSpentMs / timeLimitMs);
  const timeBonus = Math.floor(baseScore * 0.5 * timeRatio);

  return baseScore + timeBonus;
};

/**
 * Obtiene el límite de tiempo en segundos según la dificultad
 */
export const getTimeLimitForDifficulty = (
  difficulty: GameDifficulty,
): number => {
  switch (difficulty) {
    case GameDifficulty.EASY:
      return 15; // 15 segundos
    case GameDifficulty.MEDIUM:
      return 10; // 10 segundos
    case GameDifficulty.HARD:
      return 5; // 5 segundos
  }
};

/**
 * Formatea el tiempo en milisegundos a un formato legible
 */
export const formatTime = (timeMs: number): string => {
  const totalSeconds = Math.ceil(timeMs / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;

  return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
};

/**
 * Genera un mensaje según la puntuación y precisión
 */
export const getResultMessage = (
  score: number,
  totalQuestions: number,
  correctAnswers: number,
): string => {
  const accuracy = (correctAnswers / totalQuestions) * 100;

  if (accuracy >= 90) {
    return '¡Increíble! ¡Eres un Maestro Pokémon!';
  } else if (accuracy >= 70) {
    return '¡Muy bien! Estás en camino a ser un gran entrenador.';
  } else if (accuracy >= 50) {
    return 'Buen intento. Sigue practicando para mejorar.';
  } else {
    return 'Necesitas estudiar más sobre Pokémon. ¡No te rindas!';
  }
};


// -----------------------------------------------

// Relative Path: features/minigame/utils/silhouetteGenerator.ts



// -----------------------------------------------

// Relative Path: features/pokemon/hooks/hooks.ts

import { useCallback, useEffect, useState } from 'react';
import { usePokemonStore } from '../store/store';
import { pokemonRepository } from '../services/api';
import { PokemonBasic } from '../types/types';
import { ApiError } from '../../../shared/api/error-handling';

// Caso de uso: Listar Pokémon paginado
export const usePokemonList = () => {
  // Estado del store
  const {
    totalCount,
    isLoading,
    error,
    setPokemonList,
    setLoading,
    setError,
    clearError,
  } = usePokemonStore();

  // Estado local para la paginación
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [allPokemon, setAllPokemon] = useState<PokemonBasic[]>([]);
  const [isInitialized, setIsInitialized] = useState(false);
  const [isLoadingMore, setIsLoadingMore] = useState(false);

  // Función para cargar la primera página
  const fetchInitialPokemon = useCallback(async () => {
    setLoading(true);
    clearError();
    setPage(1);

    try {
      const { results, count } = await pokemonRepository.getList(20, 0);

      setAllPokemon(results);
      setPokemonList(results, count);
      setHasMore(results.length < count);
      setIsInitialized(true);
    } catch (err) {
      console.error('Error fetching initial Pokemon:', err);
      const message =
        err instanceof ApiError
          ? `Error ${err.statusCode}: ${err.message}`
          : 'Error al cargar Pokémon';
      setError(message);
    } finally {
      setLoading(false);
    }
  }, [setPokemonList, setLoading, setError, clearError]);

  // Función para cargar más Pokémon
  const fetchMorePokemon = useCallback(async () => {
    // No cargar más si ya estamos cargando o no hay más
    if (isLoadingMore || !hasMore || isLoading) return;

    setIsLoadingMore(true);
    const nextPage = page + 1;
    const offset = (nextPage - 1) * 20;

    try {
      console.log(`Loading more Pokemon: page ${nextPage}, offset ${offset}`);
      const { results, count } = await pokemonRepository.getList(20, offset);

      // Combinar con los Pokémon existentes
      const newAllPokemon = [...allPokemon, ...results];
      setAllPokemon(newAllPokemon);
      setPokemonList(newAllPokemon, count);

      // Actualizar estado de paginación
      setPage(nextPage);
      setHasMore(newAllPokemon.length < count);

      console.log(
        `Loaded ${results.length} more Pokemon. Total: ${newAllPokemon.length}/${count}`,
      );
    } catch (err) {
      console.error('Error fetching more Pokemon:', err);
      // No mostrar error en UI para carga de más, solo en consola
    } finally {
      setIsLoadingMore(false);
    }
  }, [page, allPokemon, isLoadingMore, hasMore, isLoading, setPokemonList]);

  // Cargar datos iniciales al montar
  useEffect(() => {
    if (!isInitialized) {
      fetchInitialPokemon();
    }
  }, [isInitialized, fetchInitialPokemon]);

  return {
    // Usar la lista combinada en lugar de la del store
    pokemonList: allPokemon,
    isLoading,
    isLoadingMore,
    error,
    hasMore,
    loadMore: fetchMorePokemon,
    refetch: fetchInitialPokemon,
    isInitialized,
    totalCount,
  };
};

// Caso de uso: Obtener detalle de Pokémon
export const usePokemonDetail = (idOrName: string | number) => {
  const {
    selectedPokemon,
    isLoading,
    error,
    setSelectedPokemon,
    setLoading,
    setError,
    clearError,
    favorites,
    toggleFavorite,
  } = usePokemonStore();

  const fetchPokemonDetail = useCallback(async () => {
    if (!idOrName) return;

    setLoading(true);
    clearError();

    try {
      const pokemonDetail = await pokemonRepository.getDetail(idOrName);
      setSelectedPokemon(pokemonDetail);
    } catch (err) {
      const message =
        err instanceof ApiError
          ? `Error ${err.statusCode}: ${err.message}`
          : 'Error al cargar detalles del Pokémon';
      setError(message);
    } finally {
      setLoading(false);
    }
  }, [idOrName, setSelectedPokemon, setLoading, setError, clearError]);

  useEffect(() => {
    fetchPokemonDetail();

    // Limpiar al desmontar
    return () => {
      setSelectedPokemon(null);
    };
  }, [idOrName, fetchPokemonDetail, setSelectedPokemon]);

  const isFavorite = selectedPokemon
    ? favorites.includes(selectedPokemon.id)
    : false;

  return {
    pokemon: selectedPokemon,
    isLoading,
    error,
    isFavorite,
    toggleFavorite: selectedPokemon
      ? () => toggleFavorite(selectedPokemon.id)
      : () => {},
    refetch: fetchPokemonDetail,
  };
};

// Caso de uso: Buscar Pokémon
export const useSearchPokemon = () => {
  const [searchResults, setSearchResults] = useState<PokemonBasic[]>([]);
  const [searchQuery, setSearchQuery] = useState('');

  const { pokemonList } = usePokemonList();

  const searchPokemon = useCallback(
    (query: string) => {
      if (!query.trim()) {
        setSearchResults([]);
        return;
      }

      // Búsqueda local en lugar de API
      const results = pokemonList.filter((pokemon) =>
        pokemon.name.toLowerCase().includes(query.toLowerCase()),
      );

      setSearchResults(results);
    },
    [pokemonList],
  );

  // Debounce para la búsqueda
  useEffect(() => {
    const handler = setTimeout(() => {
      searchPokemon(searchQuery);
    }, 300);

    return () => {
      clearTimeout(handler);
    };
  }, [searchQuery, searchPokemon]);

  return {
    searchQuery,
    setSearchQuery,
    searchResults,
    clearSearch: () => {
      setSearchQuery('');
      setSearchResults([]);
    },
  };
};


// -----------------------------------------------

// Relative Path: features/pokemon/screens/PokemonDetailScreen/PokemonDetailScreen.tsx

import React from 'react';
import { View, Text, Image, ScrollView, TouchableOpacity } from 'react-native';
import { RouteProp, useRoute } from '@react-navigation/native';
import { usePokemonDetail } from '../../hooks/hooks';
import { LoadingIndicator, ErrorView } from '../../../../shared/components';
import styles from './styles';
import {
  formatStatName,
  getStatColor,
  getTypeColor,
} from '../../utils/pokemonUtils';

type RouteParams = {
  PokemonDetail: {
    id: number;
  };
};

export const PokemonDetailScreen: React.FC = () => {
  const route = useRoute<RouteProp<RouteParams, 'PokemonDetail'>>();
  const { id } = route.params;

  const { pokemon, isLoading, error, isFavorite, toggleFavorite, refetch } =
    usePokemonDetail(id);

  if (isLoading && !pokemon) {
    return <LoadingIndicator />;
  }

  if (error && !pokemon) {
    return <ErrorView message={error} onRetry={refetch} />;
  }

  if (!pokemon) {
    return (
      <ErrorView message="No se pudo cargar el Pokémon" onRetry={refetch} />
    );
  }

  return (
    <ScrollView style={styles.container}>
      <View style={styles.header}>
        <Image source={{ uri: pokemon.imageUrl }} style={styles.image} />
        <View style={styles.titleContainer}>
          <Text style={styles.name}>{pokemon.name}</Text>
          <Text style={styles.id}>
            #{pokemon.id.toString().padStart(3, '0')}
          </Text>
        </View>
        <TouchableOpacity
          onPress={toggleFavorite}
          style={styles.favoriteButton}
        >
          <Text style={styles.favoriteIcon}>{isFavorite ? '★' : '☆'}</Text>
        </TouchableOpacity>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Tipos</Text>
        <View style={styles.typesContainer}>
          {pokemon.types.map((type) => (
            <View
              key={type}
              style={[styles.typeTag, { backgroundColor: getTypeColor(type) }]}
            >
              <Text style={styles.typeText}>{type}</Text>
            </View>
          ))}
        </View>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Información</Text>
        <View style={styles.infoContainer}>
          <View style={styles.infoItem}>
            <Text style={styles.infoLabel}>Altura</Text>
            <Text style={styles.infoValue}>{pokemon.height} m</Text>
          </View>
          <View style={styles.infoItem}>
            <Text style={styles.infoLabel}>Peso</Text>
            <Text style={styles.infoValue}>{pokemon.weight} kg</Text>
          </View>
        </View>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Habilidades</Text>
        <View style={styles.abilitiesContainer}>
          {pokemon.abilities.map((ability) => (
            <Text key={ability} style={styles.ability}>
              {ability.charAt(0).toUpperCase() + ability.slice(1)}
            </Text>
          ))}
        </View>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Estadísticas</Text>
        {pokemon.stats.map((stat) => (
          <View key={stat.name} style={styles.statContainer}>
            <Text style={styles.statName}>{formatStatName(stat.name)}</Text>
            <Text style={styles.statValue}>{stat.value}</Text>
            <View style={styles.statBarContainer}>
              <View
                style={[
                  styles.statBar,
                  { width: `${Math.min(100, (stat.value / 255) * 100)}%` },
                  { backgroundColor: getStatColor(stat.value) },
                ]}
              />
            </View>
          </View>
        ))}
      </View>
    </ScrollView>
  );
};


// -----------------------------------------------

// Relative Path: features/pokemon/screens/PokemonDetailScreen/styles.ts

import { StyleSheet } from 'react-native';

export default StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 20,
    backgroundColor: 'white',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  image: {
    width: 120,
    height: 120,
    marginRight: 15,
  },
  titleContainer: {
    flex: 1,
  },
  name: {
    fontSize: 24,
    fontWeight: 'bold',
  },
  id: {
    fontSize: 16,
    color: '#666',
  },
  favoriteButton: {
    padding: 10,
  },
  favoriteIcon: {
    fontSize: 24,
    color: '#FFD700',
  },
  section: {
    backgroundColor: 'white',
    margin: 10,
    padding: 15,
    borderRadius: 8,
    elevation: 2,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
    paddingBottom: 5,
  },
  typesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  typeTag: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    margin: 5,
  },
  typeText: {
    color: 'white',
    fontWeight: 'bold',
  },
  infoContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  infoItem: {
    alignItems: 'center',
  },
  infoLabel: {
    fontSize: 14,
    color: '#666',
  },
  infoValue: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  abilitiesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  ability: {
    backgroundColor: '#e0e0e0',
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 5,
    margin: 5,
  },
  statContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  statName: {
    width: 80,
    fontSize: 14,
  },
  statValue: {
    width: 30,
    textAlign: 'right',
    marginRight: 10,
    fontSize: 14,
    fontWeight: 'bold',
  },
  statBarContainer: {
    flex: 1,
    height: 10,
    backgroundColor: '#e0e0e0',
    borderRadius: 5,
    overflow: 'hidden',
  },
  statBar: {
    height: '100%',
  },
});


// -----------------------------------------------

// Relative Path: features/pokemon/screens/PokemonListScreen/PokemonListScreen.tsx

import React from 'react';
import {
  View,
  Text,
  FlatList,
  TextInput,
  TouchableOpacity,
  Image,
  ActivityIndicator,
} from 'react-native';
import { usePokemonList, useSearchPokemon } from '../../hooks/hooks';
import {
  LoadingIndicator,
  ErrorView,
  Card,
} from '../../../../shared/components';
import { PokemonBasic } from '../../types/types';
import { useNavigation } from '@react-navigation/native';
import styles from './styles';

export const PokemonListScreen: React.FC = () => {
  const {
    pokemonList,
    isLoading,
    isLoadingMore,
    error,
    hasMore,
    loadMore,
    refetch,
    isInitialized,
    totalCount,
  } = usePokemonList();

  const { searchQuery, setSearchQuery, searchResults, clearSearch } =
    useSearchPokemon();
  const navigation = useNavigation();

  const displayedPokemon = searchQuery ? searchResults : pokemonList;

  // Manejar cuando se llega al final de la lista
  const handleEndReached = () => {
    if (!searchQuery && hasMore && !isLoadingMore) {
      loadMore();
    }
  };

  const renderPokemonItem = ({ item }: { item: PokemonBasic }) => (
    <Card style={styles.card}>
      <TouchableOpacity
        onPress={() => navigation.navigate('PokemonDetail', { id: item.id })}
      >
        <Image source={{ uri: item.imageUrl }} style={styles.pokemonImage} />
        <Text style={styles.pokemonName}>{item.name}</Text>
        <Text style={styles.pokemonId}>
          #{item.id.toString().padStart(3, '0')}
        </Text>
      </TouchableOpacity>
    </Card>
  );

  // Renderizar el footer con indicador de carga o información
  const renderFooter = () => {
    if (searchQuery) return null;

    if (isLoadingMore) {
      return (
        <View style={styles.footerLoading}>
          <ActivityIndicator size="small" color="#3498db" />
          <Text style={styles.footerText}>Cargando más Pokémon...</Text>
        </View>
      );
    }

    if (pokemonList.length > 0) {
      return (
        <View style={styles.footer}>
          <Text style={styles.footerText}>
            {hasMore
              ? `Mostrando ${pokemonList.length} de ${totalCount} Pokémon`
              : `Has visto todos los ${pokemonList.length} Pokémon`}
          </Text>
        </View>
      );
    }

    return null;
  };

  // Mostrar indicador de carga solo en la carga inicial
  if (isLoading && !isInitialized) {
    return <LoadingIndicator />;
  }

  // Mostrar error solo si no hay datos para mostrar
  if (error && pokemonList.length === 0) {
    return <ErrorView message={error} onRetry={refetch} />;
  }

  return (
    <View style={styles.container}>
      <FlatList
        showsVerticalScrollIndicator={false}
        ListHeaderComponent={
          <View style={styles.searchContainer}>
            <TextInput
              style={styles.searchInput}
              placeholder="Buscar Pokémon..."
              value={searchQuery}
              onChangeText={setSearchQuery}
            />
            {searchQuery ? (
              <TouchableOpacity
                style={styles.clearButton}
                onPress={clearSearch}
              >
                <Text>×</Text>
              </TouchableOpacity>
            ) : null}
          </View>
        }
        stickyHeaderHiddenOnScroll
        stickyHeaderIndices={[0]}
        data={displayedPokemon}
        renderItem={renderPokemonItem}
        keyExtractor={(item) => item.id.toString()}
        numColumns={2}
        contentContainerStyle={styles.listContainer}
        ListEmptyComponent={
          <Text style={styles.emptyText}>
            {searchQuery
              ? 'No se encontraron Pokémon'
              : 'No hay Pokémon disponibles'}
          </Text>
        }
        onRefresh={refetch}
        refreshing={isLoading && pokemonList.length > 0}
        onEndReached={handleEndReached}
        onEndReachedThreshold={0.3}
        ListFooterComponent={renderFooter}
      />
    </View>
  );
};


// -----------------------------------------------

// Relative Path: features/pokemon/screens/PokemonListScreen/styles.ts

import { StyleSheet } from 'react-native';

export default StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
    paddingHorizontal: 10,
  },
  searchContainer: {
    flexDirection: 'row',
    borderRadius: 8,
    backgroundColor: 'white',
    overflow: 'hidden',
    elevation: 2,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: '#ccc',
    marginVertical: 10,
  },
  searchInput: {
    flex: 1,
    padding: 12,
    fontSize: 16,
  },
  clearButton: {
    padding: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  listContainer: {
    padding: 5,
  },
  card: {
    flex: 1,
    margin: 5,
    padding: 15,
    alignItems: 'center',
  },
  pokemonImage: {
    width: 120,
    height: 120,
    marginBottom: 10,
  },
  pokemonName: {
    fontSize: 16,
    fontWeight: 'bold',
    textAlign: 'center',
  },
  pokemonId: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
  },
  emptyText: {
    textAlign: 'center',
    marginTop: 50,
    fontSize: 16,
    color: '#666',
  },
  // Nuevos estilos para el footer
  footer: {
    padding: 20,
    alignItems: 'center',
  },
  footerLoading: {
    padding: 20,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  footerText: {
    fontSize: 14,
    color: '#666',
    marginLeft: 8,
  },
});


// -----------------------------------------------

// Relative Path: features/pokemon/services/api.ts

import { createApiClient } from '../../../shared/api/client';
import {
  PokemonBasic,
  PokemonDetail,
  PokemonListResponse,
  mapApiToPokemonBasic,
  mapApiToPokemonDetail,
} from '../types/types';

// Constantes
//TODO: crear archivo de constantes para las URLs de la API y las imágenes de los Pokémon
const API_BASE_URL = 'https://pokeapi.co/api/v2';
const POKEMON_SPRITE_URL =
  'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon';
const apiClient = createApiClient(API_BASE_URL);

// Adaptador de repositorio simplificado
export const pokemonRepository = {
  getList: async (
    limit = 20,
    offset = 0,
  ): Promise<{
    results: PokemonBasic[];
    count: number;
    next: string | null;
  }> => {
    try {
      // Una sola petición para obtener la lista básica
      console.log(
        `Fetching pokemon list with limit=${limit}, offset=${offset}`,
      );

      const data = await apiClient.get<PokemonListResponse>(
        `/pokemon?limit=${limit}&offset=${offset}`,
      );

      console.log(`Received list with ${data.results.length} Pokémon`);

      // Crear objetos Pokémon directamente desde la lista
      const pokemonList: PokemonBasic[] = data.results.map((pokemon) => {
        const id = extractPokemonId(pokemon.url);
        return {
          id,
          name: capitalizeFirstLetter(pokemon.name),
          imageUrl: `${POKEMON_SPRITE_URL}/${id}.png`,
        };
      });

      return {
        results: pokemonList,
        count: data.count,
        next: data.next,
      };
    } catch (error) {
      console.error('Error in getList:', error);
      return {
        results: [],
        count: 0,
        next: null,
      };
    }
  },

  // Obtener detalles de un Pokémon
  getDetail: async (idOrName: string | number): Promise<PokemonDetail> => {
    try {
      const data = await apiClient.get<any>(`/pokemon/${idOrName}`);
      return mapApiToPokemonDetail(data);
    } catch (error) {
      console.error(`Error fetching details for Pokémon ${idOrName}:`, error);
      throw error;
    }
  },

  // Buscar Pokémon por nombre
  searchByName: async (name: string): Promise<PokemonBasic[]> => {
    try {
      // La PokéAPI no tiene endpoint de búsqueda directa, así que obtenemos varios y filtramos
      const response =
        await apiClient.get<PokemonListResponse>('/pokemon?limit=100');
      const searchTerm = name.toLowerCase();

      const matchingPokemon = response.results.filter((p) =>
        p.name.includes(searchTerm),
      );

      if (matchingPokemon.length === 0) return [];

      const detailPromises = matchingPokemon.map((p) =>
        apiClient.get<any>(p.url.replace(API_BASE_URL, '')),
      );

      const pokemonDetails = await Promise.all(detailPromises);
      return pokemonDetails.map(mapApiToPokemonBasic);
    } catch (error) {
      console.error(`Error searching Pokémon by name "${name}":`, error);
      return [];
    }
  },
};

/**
 * Extrae el ID de un Pokémon de su URL
 */
function extractPokemonId(url: string): number {
  return parseInt(url.split('/').filter(Boolean).pop() || '0');
}

/**
 * Capitaliza la primera letra de un string
 */
function capitalizeFirstLetter(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}


// -----------------------------------------------

// Relative Path: features/pokemon/store/store.ts

import { create } from 'zustand';
import { persist, createJSONStorage, PersistOptions } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { PokemonBasic, PokemonDetail } from '../types/types';
import { withReactotron } from '../../../../ReactotronConfig';
import { StateCreator } from 'zustand';

interface PokemonState {
  // Estado
  pokemonList: PokemonBasic[];
  selectedPokemon: PokemonDetail | null;
  favorites: number[];
  isLoading: boolean;
  error: string | null;
  totalCount: number;

  // Acciones
  setPokemonList: (pokemon: PokemonBasic[], total: number) => void;
  setSelectedPokemon: (pokemon: PokemonDetail | null) => void;
  toggleFavorite: (pokemonId: number) => void;
  setLoading: (isLoading: boolean) => void;
  setError: (error: string | null) => void;
  clearError: () => void;
}

// Definir el creador de estado base con tipo correcto
const createPokemonStore: StateCreator<PokemonState, [], []> = (set) => ({
  // Estado inicial
  pokemonList: [],
  selectedPokemon: null,
  favorites: [],
  isLoading: false,
  error: null,
  totalCount: 0,

  // Acciones
  setPokemonList: (pokemon: PokemonBasic[], total: number) =>
    set({
      pokemonList: pokemon,
      totalCount: total,
    }),

  setSelectedPokemon: (pokemon: PokemonDetail | null) =>
    set({
      selectedPokemon: pokemon,
    }),

  toggleFavorite: (pokemonId: number) =>
    set((state) => {
      const isFavorite = state.favorites.includes(pokemonId);
      const newFavorites = isFavorite
        ? state.favorites.filter((id) => id !== pokemonId)
        : [...state.favorites, pokemonId];

      return { favorites: newFavorites };
    }),

  setLoading: (isLoading: boolean) => set({ isLoading }),

  setError: (error: string | null) => set({ error }),

  clearError: () => set({ error: null }),
});

// Opciones de persistencia
const persistOptions: PersistOptions<
  PokemonState,
  Pick<PokemonState, 'favorites'>
> = {
  name: 'pokemon-storage',
  storage: createJSONStorage(() => AsyncStorage),
  partialize: (state) => ({
    favorites: state.favorites,
  }),
  version: 1,
  onRehydrateStorage: () => {
    return (state, error) => {
      if (error) {
        console.error('Error al hidratar el estado:', error);
      } else {
        console.log('Estado hidratado correctamente');

        // Registrar en Reactotron cuando se completa la hidratación
        if (__DEV__ && state) {
          import('../../../../ReactotronConfig')
            .then(({ default: reactotron }) => {
              reactotron.display({
                name: 'ZUSTAND [PokemonStore] - REHYDRATED',
                preview: 'Estado restaurado del almacenamiento',
                value: state,
              });
            })
            .catch(console.error);
        }
      }
    };
  },
  migrate: (persistedState: any, version) => {
    if (version === 0) {
      return {
        ...persistedState,
      };
    }
    return persistedState as Partial<PokemonState>;
  },
};

// Crear el store con middleware
export const usePokemonStore = create<PokemonState>()(
  persist(
    // Aplicar el middleware de Reactotron en desarrollo
    __DEV__
      ? withReactotron('PokemonStore', createPokemonStore)
      : createPokemonStore,
    persistOptions,
  ),
);

// El resto de tu código (selectores y acciones) permanece igual
export const usePokemonList = () =>
  usePokemonStore((state) => ({
    pokemonList: state.pokemonList,
    isLoading: state.isLoading,
    error: state.error,
    totalCount: state.totalCount,
  }));

export const usePokemonDetail = () =>
  usePokemonStore((state) => ({
    selectedPokemon: state.selectedPokemon,
    isLoading: state.isLoading,
    error: state.error,
  }));

export const usePokemonFavorites = () =>
  usePokemonStore((state) => ({
    favorites: state.favorites,
    toggleFavorite: state.toggleFavorite,
  }));

export const pokemonActions = {
  loadAndFavorite: async (id: number) => {
    const { setLoading, setError, toggleFavorite } = usePokemonStore.getState();

    setLoading(true);
    try {
      toggleFavorite(id);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Error desconocido');
    } finally {
      setLoading(false);
    }
  },

  resetStore: () => {
    usePokemonStore.setState({
      pokemonList: [],
      selectedPokemon: null,
      isLoading: false,
      error: null,
      totalCount: 0,
    });
  },
};


// -----------------------------------------------

// Relative Path: features/pokemon/types/types.ts

export interface PokemonBasic {
  id: number;
  name: string;
  imageUrl: string;
}

export interface PokemonDetail extends PokemonBasic {
  height: number;
  weight: number;
  types: string[];
  stats: {
    name: string;
    value: number;
  }[];
  abilities: string[];
}

export interface PokemonListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: {
    name: string;
    url: string;
  }[];
}

// Transformadores para mapear entre API y dominio
export const mapApiToPokemonBasic = (apiData: any): PokemonBasic => {
  console.log('Mapping Pokemon data:', apiData.name);

  // Manejar posibles valores nulos o indefinidos en la ruta de la imagen
  const sprites = apiData.sprites || {};
  const other = sprites.other || {};
  const officialArtwork = other['official-artwork'] || {};

  return {
    id: apiData.id,
    name: apiData.name
      ? apiData.name.charAt(0).toUpperCase() + apiData.name.slice(1)
      : 'Unknown',
    imageUrl:
      officialArtwork.front_default ||
      sprites.front_default ||
      'https://via.placeholder.com/150?text=Pokemon',
  };
};

export const mapApiToPokemonDetail = (apiData: any): PokemonDetail => ({
  ...mapApiToPokemonBasic(apiData),
  height: apiData.height / 10, // Convertir a metros
  weight: apiData.weight / 10, // Convertir a kg
  types: apiData.types.map((t: any) => t.type.name),
  stats: apiData.stats.map((s: any) => ({
    name: s.stat.name,
    value: s.base_stat,
  })),
  abilities: apiData.abilities.map((a: any) => a.ability.name),
});


// -----------------------------------------------

// Relative Path: features/pokemon/utils/pokemonUtils.ts

// Funciones auxiliares
export const getTypeColor = (type: string): string => {
  const colors: Record<string, string> = {
    normal: '#A8A878',
    fire: '#F08030',
    water: '#6890F0',
    electric: '#F8D030',
    grass: '#78C850',
    ice: '#98D8D8',
    fighting: '#C03028',
    poison: '#A040A0',
    ground: '#E0C068',
    flying: '#A890F0',
    psychic: '#F85888',
    bug: '#A8B820',
    rock: '#B8A038',
    ghost: '#705898',
    dragon: '#7038F8',
    dark: '#705848',
    steel: '#B8B8D0',
    fairy: '#EE99AC',
  };

  return colors[type] || '#777777';
};

export const getStatColor = (value: number): string => {
  if (value < 50) return '#ff7675';
  if (value < 100) return '#fdcb6e';
  return '#00b894';
};

export const formatStatName = (name: string): string => {
  const statNames: Record<string, string> = {
    hp: 'HP',
    attack: 'Ataque',
    defense: 'Defensa',
    'special-attack': 'Atq. Esp.',
    'special-defense': 'Def. Esp.',
    speed: 'Velocidad',
  };

  return statNames[name] || name;
};


// -----------------------------------------------

// Relative Path: navigation/AppNavigator.tsx

import React, { useEffect } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { ActivityIndicator, View } from 'react-native';
import { AuthNavigator } from './AuthNavigator';
import { MainNavigator } from './MainNavigator';
import { RootStackParamList } from './types';
import { useAuthStore } from '../features/authentication';

const RootStack = createStackNavigator<RootStackParamList>();

export const AppNavigator: React.FC = () => {
  const { user, isLoading, initialize, cleanup } = useAuthStore();

  useEffect(() => {
    initialize();

    return () => {
      cleanup();
    };
  }, [initialize, cleanup]);

  if (isLoading) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" color="#f44336" />
      </View>
    );
  }

  return (
    <NavigationContainer>
      <RootStack.Navigator screenOptions={{ headerShown: false }}>
        {user ? (
          <RootStack.Screen name="Main" component={MainNavigator} />
        ) : (
          <RootStack.Screen name="Auth" component={AuthNavigator} />
        )}
      </RootStack.Navigator>
    </NavigationContainer>
  );
};

// -----------------------------------------------

// Relative Path: navigation/AuthNavigator.tsx

import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import { AuthStackParamList } from './types';
import {
  LoginScreen,
  PasswordResetScreen,
  RegisterScreen,
} from '../features/authentication';

const AuthStack = createStackNavigator<AuthStackParamList>();

export const AuthNavigator: React.FC = () => {
  return (
    <AuthStack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: '#c62828',
        },
        headerTintColor: '#fff',
        headerTitleStyle: {
          fontWeight: 'bold',
        },
      }}
    >
      <AuthStack.Screen
        name="Login"
        component={LoginScreen}
        options={{ headerShown: false }}
      />
      <AuthStack.Screen
        name="Register"
        component={RegisterScreen}
        options={{ title: 'Crear Cuenta' }}
      />
      <AuthStack.Screen
        name="PasswordReset"
        component={PasswordResetScreen}
        options={{ title: 'Recuperar Contraseña' }}
      />
    </AuthStack.Navigator>
  );
};


// -----------------------------------------------

// Relative Path: navigation/MainNavigator.tsx

import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import { View } from 'react-native';
import { PokemonListScreen } from '../features/pokemon/screens/PokemonListScreen/PokemonListScreen';
import { PokemonDetailScreen } from '../features/pokemon/screens/PokemonDetailScreen/PokemonDetailScreen';
import { ProfileScreen } from '../features/authentication/screens/ProfileScreen';
import { MinigameHomeScreen } from '../features/minigame/screens/MinigameHomeScreen';
import { WhosThatPokemonScreen } from '../features/minigame/screens/WhosThatPokemonScreen';
import { MainStackParamList } from './types';
import { HeaderProfileButton } from '../shared/components/HeaderProfileButton/HeaderProfileButton';
import { HeaderMinigameButton } from '../shared/components/HeaderMinigameButton/HeaderMinigameButton';

const MainStack = createStackNavigator<MainStackParamList>();

export const MainNavigator: React.FC = () => {
  return (
    <MainStack.Navigator
      initialRouteName="PokemonList"
      screenOptions={{
        headerStyle: {
          backgroundColor: '#f44336',
        },
        headerTintColor: '#fff',
        headerTitleStyle: {
          fontWeight: 'bold',
        },
      }}
    >
      <MainStack.Screen
        name="PokemonList"
        component={PokemonListScreen}
        options={({ navigation }) => ({
          title: "Pokemon's Expo App",
          headerRight: () => (
            <View style={{ flexDirection: 'row' }}>
              <HeaderMinigameButton
                onPress={() => navigation.navigate('MinigameHome')}
              />
              <HeaderProfileButton
                onPress={() => navigation.navigate('Profile')}
              />
            </View>
          ),
        })}
      />
      <MainStack.Screen
        name="PokemonDetail"
        component={PokemonDetailScreen}
        options={({ route }) => ({
          title: `Pokémon #${route.params?.id || ''}`,
        })}
      />
      <MainStack.Screen
        name="Profile"
        component={ProfileScreen}
        options={{ title: 'Mi Perfil' }}
      />
      <MainStack.Screen
        name="MinigameHome"
        component={MinigameHomeScreen}
        options={{ title: 'Minijuegos Pokémon' }}
      />
      <MainStack.Screen
        name="WhosThatPokemon"
        component={WhosThatPokemonScreen}
        options={{
          title: '¿Quién es ese Pokémon?',
          headerShown: false,
        }}
      />
    </MainStack.Navigator>
  );
};


// -----------------------------------------------

// Relative Path: navigation/types.ts

import { StackNavigationProp } from '@react-navigation/stack';
import { RouteProp } from '@react-navigation/native';
import {
  GameDifficulty,
  GameType,
} from '../features/minigame/types/minigame.types';

// Tipos para el stack principal
export type MainStackParamList = {
  PokemonList: undefined;
  PokemonDetail: { id: number };
  Profile: undefined;
  MinigameHome: undefined;
  WhosThatPokemon: {
    gameType: GameType;
    difficulty: GameDifficulty;
    questionCount: number;
  };
};

// Tipos para el stack de autenticación
export type AuthStackParamList = {
  Login: undefined;
  Register: undefined;
  PasswordReset: undefined;
};

// Tipos para el stack raíz
export type RootStackParamList = {
  Auth: undefined;
  Main: undefined;
};

// Tipos para la navegación
export type MainNavigationProp<T extends keyof MainStackParamList> =
  StackNavigationProp<MainStackParamList, T>;

export type AuthNavigationProp<T extends keyof AuthStackParamList> =
  StackNavigationProp<AuthStackParamList, T>;

// Tipos para las rutas
export type MainRouteProp<T extends keyof MainStackParamList> = RouteProp<
  MainStackParamList,
  T
>;

export type AuthRouteProp<T extends keyof AuthStackParamList> = RouteProp<
  AuthStackParamList,
  T
>;


// -----------------------------------------------

// Relative Path: shared/api/client.ts

import axios from 'axios';
import { ApiError } from './error-handling';

export const createApiClient = (baseURL: string) => {
  const axiosInstance = axios.create({
    baseURL,
    timeout: 10000,
    headers: {
      'Content-Type': 'application/json',
    },
  });

  const get = async <T>(endpoint: string): Promise<T> => {
    try {
      const response = await axiosInstance.get<T>(endpoint);
      return response.data;
    } catch (error) {
      console.error('API Error:', error);
      if (axios.isAxiosError(error)) {
        throw new ApiError(
          error.response?.status || 0,
          error.message,
          error.response?.data,
        );
      }
      throw new ApiError(0, (error as Error).message || 'Unknown error');
    }
  };

  //Post
  //Delete
  //Put

  return { get };
};


// -----------------------------------------------

// Relative Path: shared/api/error-handling.ts

export class ApiError extends Error {
  constructor(
    public statusCode: number,
    message: string,
    public data?: any,
  ) {
    super(message);
  }

  static fromResponse(response: Response, data?: any): ApiError {
    return new ApiError(
      response.status,
      data?.message || response.statusText,
      data,
    );
  }
}


// -----------------------------------------------

// Relative Path: shared/components/Card/index.tsx

import React from 'react';
import { View, ViewStyle } from 'react-native';
import styles from './styles';

interface CardProps {
  children: React.ReactNode;
  style?: ViewStyle;
}

export const Card: React.FC<CardProps> = ({ children, style }) => {
  return <View style={[styles.card, style]}>{children}</View>;
};


// -----------------------------------------------

// Relative Path: shared/components/Card/styles.ts

import { StyleSheet } from 'react-native';

export default StyleSheet.create({
  card: {
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 15,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
});


// -----------------------------------------------

// Relative Path: shared/components/ErrorView/index.tsx

import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import styles from './styles';

interface ErrorViewProps {
  message: string;
  onRetry?: () => void;
}

export const ErrorView: React.FC<ErrorViewProps> = ({ message, onRetry }) => {
  return (
    <View style={styles.container}>
      <Text style={styles.errorIcon}>⚠️</Text>
      <Text style={styles.errorText}>{message}</Text>
      {onRetry && (
        <TouchableOpacity style={styles.retryButton} onPress={onRetry}>
          <Text style={styles.retryText}>Reintentar</Text>
        </TouchableOpacity>
      )}
    </View>
  );
};


// -----------------------------------------------

// Relative Path: shared/components/ErrorView/styles.ts

import { StyleSheet } from 'react-native';

export default StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorIcon: {
    fontSize: 48,
    marginBottom: 16,
  },
  errorText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 20,
  },
  retryButton: {
    backgroundColor: '#f44336',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 5,
  },
  retryText: {
    color: 'white',
    fontWeight: 'bold',
  },
});


// -----------------------------------------------

// Relative Path: shared/components/HeaderMinigameButton/HeaderMinigameButton.tsx

import React from 'react';
import { TouchableOpacity, StyleSheet } from 'react-native';
import { MaterialIcons } from '@expo/vector-icons';

interface HeaderMinigameButtonProps {
  onPress: () => void;
}

export const HeaderMinigameButton: React.FC<HeaderMinigameButtonProps> = ({
  onPress,
}) => {
  return (
    <TouchableOpacity onPress={onPress} style={styles.container}>
      <MaterialIcons name="sports-esports" size={24} color="#fff" />
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 8,
    marginRight: 5,
  },
});


// -----------------------------------------------

// Relative Path: shared/components/HeaderProfileButton/HeaderProfileButton.tsx

import React from 'react';
import { TouchableOpacity } from 'react-native';
import { MaterialIcons as Icon } from '@expo/vector-icons';

interface HeaderProfileButtonProps {
  onPress: () => void;
}

export const HeaderProfileButton: React.FC<HeaderProfileButtonProps> = ({
  onPress,
}) => {
  return (
    <TouchableOpacity onPress={onPress} style={{ padding: 5 }}>
      <Icon name="person" size={24} color="#fff" />
    </TouchableOpacity>
  );
};


// -----------------------------------------------

// Relative Path: shared/components/LoadingIndicator/index.tsx

import React from 'react';
import { View, ActivityIndicator } from 'react-native';
import styles from './styles';

export const LoadingIndicator: React.FC = () => {
  return (
    <View style={styles.container}>
      <ActivityIndicator size="large" color="#f44336" />
    </View>
  );
};


// -----------------------------------------------

// Relative Path: shared/components/LoadingIndicator/styles.ts

import { StyleSheet } from 'react-native';

export default StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});


// -----------------------------------------------

// Relative Path: shared/components/index.ts

import { Card } from './Card';
import { ErrorView } from './ErrorView';
import { LoadingIndicator } from './LoadingIndicator';

export { Card, ErrorView, LoadingIndicator };


// -----------------------------------------------

// Relative Path: shared/hooks/useToast.ts



// -----------------------------------------------

